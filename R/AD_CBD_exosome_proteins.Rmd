---
title: "AD CBD Exosome Proteins"
author:
  - name: "Emir Turkes [et2628@cumc.columbia.edu]"
  - name: "Columbia University"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
bibliography: "../AD-CBD-exosome-proteins.bib"
biblio-style: apalike
link-citations: true
output:
  html_document:
    code_folding: show
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 2
    toc_float:
      collapsed: false
      smooth_scroll: false
knit:
  (function(inputFile, encoding) {
    rmarkdown::render(
      inputFile, encoding = encoding,
      output_file = "../results/AD-CBD-exosome-proteins-report.html")})
---

```{r, include = FALSE}
#    This file is part of AD-CBD-exosome-proteins.
#    Copyright (C) 2019  Emir Turkes
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Emir Turkes can be contacted at emir.turkes@eturkes.com

knitr::opts_chunk$set(fig.width = 8.5, fig.height = 7)
```

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
div.main-container {max-width: none; width: 100%;}
</style>

*This is an in-depth analysis based using one or more cleaned datasets.*

The goal of this analysis is to compare exosome proteins between control, Alzheimer's Disease (AD), and Corticobasal Degeneration (CBD) samples.

Datasets used in this analysis include:

- Mass spectrometry data of exosome proteins analyzed with MaxQuant.

This analysis was performed in R except where noted.
The source code and instructions for rerunning the analysis can be found at [github.com/eturkes/AD-CBD-exosome-proteins](https://github.com/eturkes/AD-CBD-exosome-proteins).

# Final Results

**Read just the following sub-section for the final results of the analysis and a brief summary of the methods.**

# ~~~ Breakdown of Methods ~~~ {-}

**Sections from here to the end break down the methods used and are optional to read.**

We start by loading in any required packages and setting some global variables.

```{r}
packages <- c("conflicted", "DT", "data.table", "readxl", "pheatmap", "plyr")
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))

assets_dir <- file.path(getwd(), "..", "assets")
results_dir <- file.path(getwd(), "..", "results")

# Adds download buttons and exponential values.
datatable_custom <- function(dt) {
  datatable(
    dt,
    extensions = "Buttons", options = list(dom = "Blfrtip", buttons = list(
      "copy", "print",
      list(extend = "collection", buttons = c("csv", "excel", "pdf"), text = "Download")),
    rowCallback = JS(
      "function(row, data) {",
        "for (i = 1; i < data.length; i++) {",
          "if (data[i]>=1000 | data[i]<1000) {",
            "$('td:eq('+i+')', row).html(data[i].toExponential(2));}}}")))}

# From http://www.dr-spiess.de/Rscripts.html
rbind.na <- function (..., deparse.level = 1) 
{
    na <- nargs() - (!missing(deparse.level))
    deparse.level <- as.integer(deparse.level)
    stopifnot(0 <= deparse.level, deparse.level <= 2)
    argl <- list(...)
    while (na > 0 && is.null(argl[[na]])) {
        argl <- argl[-na]
        na <- na - 1
    }    
    if (na == 0) 
        return(NULL)
    if (na == 1) {
        if (isS4(..1)) 
            return(rbind2(..1))
        else return(matrix(..., nrow = 1)) ##.Internal(rbind(deparse.level, ...)))
    }
    if (deparse.level) {
        symarg <- as.list(sys.call()[-1L])[1L:na]
        Nms <- function(i) {
            if (is.null(r <- names(symarg[i])) || r == "") {
                if (is.symbol(r <- symarg[[i]]) || deparse.level == 
                  2) 
                  deparse(r)
            }
            else r
        }
    }
    
    ## deactivated, otherwise no fill in with two arguments
    if (na == 0) {
        r <- argl[[2]]
        fix.na <- FALSE
    }
    else {
        nrs <- unname(lapply(argl, ncol))
        iV <- sapply(nrs, is.null)
        fix.na <- identical(nrs[(na - 1):na], list(NULL, NULL))
        ## deactivated, otherwise data will be recycled
        #if (fix.na) {
        #    nr <- max(if (all(iV)) sapply(argl, length) else unlist(nrs[!iV]))
        #    argl[[na]] <- rbind(rep(argl[[na]], length.out = nr), 
        #        deparse.level = 0)
        #}
        if (deparse.level) {
            if (fix.na) 
                fix.na <- !is.null(Nna <- Nms(na))
            if (!is.null(nmi <- names(argl))) 
                iV <- iV & (nmi == "")
            ii <- if (fix.na) 
                2:(na - 1)
            else 2:na
            if (any(iV[ii])) {
                for (i in ii[iV[ii]]) if (!is.null(nmi <- Nms(i))) 
                  names(argl)[i] <- nmi
            }
        }
        
        ## filling with NA's to maximum occuring ncols
        nCol <- as.numeric(sapply(argl, function(x) if (is.null(ncol(x))) length(x)
                                                    else ncol(x)))
        maxCol <- max(nCol, na.rm = TRUE)  
        argl <- lapply(argl, function(x)  if (is.null(ncol(x))) c(x, rep(NA, maxCol - length(x)))
                                          else cbind(x, matrix(, nrow(x), maxCol - ncol(x))))  
        
        ## create a common name vector from the
        ## column names of all 'argl' items
        namesVEC <- rep(NA, maxCol)  
        for (i in 1:length(argl)) {
          CN <- colnames(argl[[i]])          
          m <- !(CN %in% namesVEC)
          namesVEC[m] <- CN[m]          
        }  
        
        ## make all column names from common 'namesVEC'
        for (j in 1:length(argl)) {    
          if (!is.null(ncol(argl[[j]]))) colnames(argl[[j]]) <- namesVEC
        }
        
        r <- do.call(rbind, c(argl[-1L], list(deparse.level = deparse.level)))        
    }
    
    d2 <- dim(r)
    
    ## make all column names from common 'namesVEC'
    colnames(r) <- colnames(argl[[1]])
    
    r <- rbind2(argl[[1]], r)
        
    if (deparse.level == 0) 
        return(r)
    ism1 <- !is.null(d1 <- dim(..1)) && length(d1) == 2L
    ism2 <- !is.null(d2) && length(d2) == 2L && !fix.na
    if (ism1 && ism2) 
        return(r)
    Nrow <- function(x) {
        d <- dim(x)
        if (length(d) == 2L) 
            d[1L]
        else as.integer(length(x) > 0L)
    }
    nn1 <- !is.null(N1 <- if ((l1 <- Nrow(..1)) && !ism1) Nms(1))
    nn2 <- !is.null(N2 <- if (na == 2 && Nrow(..2) && !ism2) Nms(2))
    if (nn1 || nn2 || fix.na) {
        if (is.null(rownames(r))) 
            rownames(r) <- rep.int("", nrow(r))
        setN <- function(i, nams) rownames(r)[i] <<- if (is.null(nams)) 
            ""
        else nams
        if (nn1) 
            setN(1, N1)
        if (nn2) 
            setN(1 + l1, N2)
        if (fix.na) 
            setN(nrow(r), Nna)
    }
    r
}

# From http://www.dr-spiess.de/Rscripts.html
cbind.na <- function (..., deparse.level = 1) 
{
    na <- nargs() - (!missing(deparse.level))    
    deparse.level <- as.integer(deparse.level)
    stopifnot(0 <= deparse.level, deparse.level <= 2)
    argl <- list(...)   
    while (na > 0 && is.null(argl[[na]])) {
        argl <- argl[-na]
        na <- na - 1
    }
    if (na == 0) 
        return(NULL)
    if (na == 1) {         
        if (isS4(..1)) 
            return(cbind2(..1))
        else return(matrix(...))  ##.Internal(cbind(deparse.level, ...)))
    }
    if (deparse.level) {       
        symarg <- as.list(sys.call()[-1L])[1L:na]
        Nms <- function(i) {
            if (is.null(r <- names(symarg[i])) || r == "") {
                if (is.symbol(r <- symarg[[i]]) || deparse.level == 
                  2) 
                  deparse(r)
            }
            else r
        }
    }   
    ## deactivated, otherwise no fill in with two arguments
    if (na == 0) {
        r <- argl[[2]]
        fix.na <- FALSE
    }
    else {
        nrs <- unname(lapply(argl, nrow))
        iV <- sapply(nrs, is.null)
        fix.na <- identical(nrs[(na - 1):na], list(NULL, NULL))
        ## deactivated, otherwise data will be recycled
        #if (fix.na) {
        #    nr <- max(if (all(iV)) sapply(argl, length) else unlist(nrs[!iV]))
        #    argl[[na]] <- cbind(rep(argl[[na]], length.out = nr), 
        #        deparse.level = 0)
        #}       
        if (deparse.level) {
            if (fix.na) 
                fix.na <- !is.null(Nna <- Nms(na))
            if (!is.null(nmi <- names(argl))) 
                iV <- iV & (nmi == "")
            ii <- if (fix.na) 
                2:(na - 1)
            else 2:na
            if (any(iV[ii])) {
                for (i in ii[iV[ii]]) if (!is.null(nmi <- Nms(i))) 
                  names(argl)[i] <- nmi
            }
        }
           
        ## filling with NA's to maximum occuring nrows
        nRow <- as.numeric(sapply(argl, function(x) NROW(x)))
        maxRow <- max(nRow, na.rm = TRUE)  
        argl <- lapply(argl, function(x)  if (is.null(nrow(x))) c(x, rep(NA, maxRow - length(x)))
                                          else rbind.na(x, matrix(, maxRow - nrow(x), ncol(x))))
        r <- do.call(cbind, c(argl[-1L], list(deparse.level = deparse.level)))
    }
    d2 <- dim(r)
    r <- cbind2(argl[[1]], r)
    if (deparse.level == 0) 
        return(r)
    ism1 <- !is.null(d1 <- dim(..1)) && length(d1) == 2L
    ism2 <- !is.null(d2) && length(d2) == 2L && !fix.na
    if (ism1 && ism2) 
        return(r)
    Ncol <- function(x) {
        d <- dim(x)
        if (length(d) == 2L) 
            d[2L]
        else as.integer(length(x) > 0L)
    }
    nn1 <- !is.null(N1 <- if ((l1 <- Ncol(..1)) && !ism1) Nms(1))
    nn2 <- !is.null(N2 <- if (na == 2 && Ncol(..2) && !ism2) Nms(2))
    if (nn1 || nn2 || fix.na) {
        if (is.null(colnames(r))) 
            colnames(r) <- rep.int("", ncol(r))
        setN <- function(i, nams) colnames(r)[i] <<- if (is.null(nams)) 
            ""
        else nams
        if (nn1) 
            setN(1, N1)
        if (nn2) 
            setN(1 + l1, N2)
        if (fix.na) 
            setN(ncol(r), Nna)
    }
    r
}
```

# Original Data

This section contains the original data received from the mass spec facility and was mainly processed using MaxQuant.

```{r}
AD_control <- data.table(read_excel(
  file.path(assets_dir, "max-quant", "AD_CONTROL_DIFFERENCE_08202019.xls"), na = "NaN"))
CBD_control <- data.table(read_excel(
  file.path(assets_dir, "max-quant", "CBD_CONTROL_DIFFERENCE_08202019.xls"), na = "NaN"))
AD_CBD <- data.table(read_excel(
  file.path(assets_dir, "max-quant", "AD_CDB_DIFFERENCE_08202019.xls"), na = "NaN"))
sets <- list(AD_control, CBD_control, AD_CBD)
rm(AD_control, CBD_control, AD_CBD)

datatable_custom(sets[[1]])
datatable_custom(sets[[2]])
datatable_custom(sets[[3]])
```

# Preliminary Cleaning

```{r}
sets <- lapply(sets, function(x) x[ , c(6, 3, 2)])
sets <- lapply(sets, function(x) rename(x, c("Gene names" = "Genes", "p value" = "p_value")))
sets[[1]] <- rename(sets[[1]], c("AD_Control fold diff" = "AD_Control_Fold_Change"))
sets[[2]] <- rename(sets[[2]], c("CBD_Control_Fold difference" = "CBD_Control_Fold_Change"))
sets[[3]] <- rename(sets[[3]], c("AD_CDB_FoldDifference" = "AD_CBD_Fold_Change"))
sets <- lapply(sets, function(x) x[!x$Genes == "", ])
sets <- lapply(sets, function(x) x[x$p_value < 0.05, ])
sets <- lapply(sets, function(x) x[order(-x[ , 2])])

datatable_custom(sets[[1]]) %>%
  formatStyle("Genes", `text-align` = "center")
datatable_custom(sets[[2]]) %>%
  formatStyle("Genes", `text-align` = "center")
datatable_custom(sets[[3]]) %>%
  formatStyle("Genes", `text-align` = "center")
```

# Overlapping Genes

```{r}
combined_set <- cbind.na(sets[[1]][ , 1:2], sets[[2]][ , 1:2], sets[[3]][ , 1:2])
datatable_custom(combined_set)

merged_set <- Reduce(function(...) merge(..., all = TRUE), list(
  sets[[2]][ , 1:2], sets[[3]][ , 1:2]), sets[[1]][ , 1:2])
merged_set <- merged_set[!(is.na(merged_set$Genes) | merged_set$Genes == ""), ]
merged_set[is.na(merged_set)] <- 0

AD_control <- head(merged_set[order(-merged_set$AD_Control_Fold_Change)], n = 10)
CBD_control <- head(merged_set[order(-merged_set$CBD_Control_Fold_Change)], n = 10)
AD_CBD <- head(merged_set[order(-merged_set$AD_CBD_Fold_Change)], n = 10)

genes <- merged_set$Genes
merged_set <- merged_set[ , 2:4]
rownames(merged_set) <- genes
datatable_custom(merged_set)

merged_top <- Reduce(function(...) merge(..., all = TRUE), list(
  CBD_control[ , c(1, 3)], AD_CBD[ , c(1, 4)]), AD_control[ , c(1, 2)])
merged_top <- merged_top[!(is.na(merged_top$Genes) | merged_top$Genes == ""), ]
merged_top[is.na(merged_top)] <- 0
top_genes <- merged_top$Genes
merged_top <- merged_top[ , 2:4]
rownames(merged_top) <- top_genes
datatable_custom(merged_top)

merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
pheatmap(merged_top, scale = "row")
```
