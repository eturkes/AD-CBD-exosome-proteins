---
title: "AD Fractions With Scaling Factor"
author:
  - name: "Emir, Pal, and Steph"
date: '`r strftime(Sys.time(), "%B %d, %Y")`'
bibliography: "../AD-CBD-exosome-proteins.bib"
link-citations: true
output:
  html_document:
    code_folding: hide
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(
    "..", "results", "AD-fractions-with-scaling-factor.html"
  ))})
---

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
.tocify-subheader .tocify-subheader .tocify-item {
  font-size: 0.95em; padding-left: 35px; text-indent: 0;
}
div.main-container {max-width: none; width: 100%;}
</style>

*This file is a part of [AD-CBD-exosome-proteins](https://github.com/eturkes/AD-CBD-exosome-proteins).*
*Please email for access.*

The data here will be referenced using the name `fractions`.
It is a label-free mass spec dataset consisting of 1 Alzheimer's Disease (AD) human brain tissue donor where extracellular vesicles (EVs) were isolated and fractionated into 8 fractions.
Each sample in the dataset represents a fraction from this single donor.

```{r}
# Some standard boilerplate.
# --------------------------
# Copyright 2019-2022 Emir Turkes, Guar Pallavi, Stephanie Fowler, UK DRI at UCL, Columbia
# University Medical Center
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This section should be checked per document.
# --------------------------------------------
packages <- c(
  "conflicted", "stringr", "DT", "DEP", "SummarizedExperiment", "ggplot2", "ComplexHeatmap",
  "RColorBrewer", "stringi", "circlize", "pRolocdata", "GSEABase", "GSVA", "limma"
)
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))
conflict_prefer("trimws", "base", quiet = TRUE)
source(file.path("utils.R"))

data_name <- "fractions"
`%notin%` <- Negate(`%in%`)
# --------------------------------------------

# Everything else in this chunk remains generally unchanged.
# ----------------------------------------------------------
assets_dir <- file.path("..", "assets") # Backed up data.

cache_dir <- file.path("..", "tmp", "cache", data_name)
if (!dir.exists(cache_dir)) {
  dir.create(cache_dir, recursive = TRUE)
}

knitr::opts_chunk$set(fig.width = 10, fig.height = 7, dpi = 300)
# ----------------------------------------------------------
# --------------------------
```

This time we apply a scaling factor that accounts for different concentration loading of each fraction.
No additional normalization is applied.

# Prep

Read in the data and organize into a `SummarizedExperiment` object.

```{r}
data <- read.delim(file.path(assets_dir, data_name, "proteinGroups.txt"))

remove <- which(data$Fasta.headers == "")
data <- data[-remove, ]

data <- dplyr::filter(data, Reverse != "+", Potential.contaminant != "+")

data$gene_names <- data$Gene
for (i in 1:length(data$gene_names)) {
  data$gene_names[i] <- getGN(data$Fasta.headers[i])
}
data <- make_unique(data, "gene_names", "Protein.IDs", ";")

LFQ_columns <- grep("LFQ.intensity.", colnames(data))
colnames(data)[LFQ_columns] <- gsub("_.*", "", colnames(data[ , LFQ_columns]))
label <- gsub("LFQ.intensity.", "", colnames(data)[LFQ_columns])

experimental_design <- data.frame(
  label = label, condition = c(rep("fraction", 8)), replicate = label
)

data <- make_se(data, LFQ_columns, experimental_design)
data
```

**Unaltered data, already log2 transformed**

```{r}
datatable_download(assay(data))
```

**After removal of log transformation**

```{r}
datatable_download(2 ^ assay(data))
```

# QC

We apply quality control to the data.

## Summary Statistics

Basic descriptions of the data such as distributions.
For now we just have a histogram.

```{r}
hist(assay(data), n = 100)
```

## Missing Value Removal

Because the dataset has no replicates, we do not perform missing value removal aside from proteins not detected in any fraction (done already).
We do however, visualise the missingness.

```{r}
plot_numbers(data)
plot_frequency(data)
plot_detect(data)
plot_missval(data)

remove <- which(apply(assay(data), 1, function(x) all(is.na(x))))
cat(length(remove), "proteins with all missing values:", names(remove))
data <- data[-remove, ]
data

plot_numbers(data)
plot_frequency(data)
plot_detect(data)
plot_missval(data)
```

**Data before normalization but after removal of missing values**

```{r}
datatable_download(assay(data))
```

**Complete cases (proteins with no missing values) before normalization but after removal of missing values**

```{r}
complete_cases <- filter_proteins(data, "complete")
datatable_download(assay(complete_cases))
```

## Normalization

This time we "undo" different concentration loadings applied to each fraction by applying a scaling factor.
No additional normalization is applied.

```{r}
concentrations <- c(0.2, 0.5, 0.5, 0.5, 0.5, 0.2, 0.2, 1)
multipliers <- min(concentrations, na.rm = TRUE) / concentrations

meanSdPlot(data)
data_norm <- data
assay(data_norm) <- 2 ^ assay(data_norm) # Undo log transformation.
for (i in seq_along(multipliers)) {
  assay(data_norm)[ , i] <- assay(data_norm)[ , i] * multipliers[i]
}
assay(data_norm) <- log2(assay(data_norm))
meanSdPlot(data_norm)
plot_normalization(data, data_norm)
data <- data_norm

meanSdPlot(complete_cases)
data_norm <- complete_cases
assay(data_norm) <- 2 ^ assay(data_norm) # Undo log transformation.
for (i in seq_along(multipliers)) {
  assay(data_norm)[ , i] <- assay(data_norm)[ , i] * multipliers[i]
}
assay(data_norm) <- log2(assay(data_norm))
meanSdPlot(data_norm)
plot_normalization(complete_cases, data_norm)
complete_cases <- data_norm

rm(data_norm)
```

**Data after normalization and log2 transformation**
**This is final form used for differential expression analysis**

No missing value imputation is performed due to the lack of replicates.

```{r}
datatable_download(assay(data))
```

## PCA

Principal component analysis using all complete cases in dataset.
Dataset with missing values not compatible with PCA.

### PCs 1 and 2

```{r}
plot_pca(
  complete_cases, n = dim(complete_cases)[1], indicate = c("condition", "label"), label = TRUE
) +
  scale_shape_manual(values = seq(0, ncol(complete_cases))) +
  ggtitle("PCA Plot")
```

### PC 1 only

Interestingly, PC1 perfectly orders the samples by fraction order.
Here we plot PC1 on both axes to highlight this.

```{r}
plot_pca(
  complete_cases, 1, 1, n = dim(complete_cases)[1], indicate = c("condition", "label"), label = TRUE
) +
  scale_shape_manual(values = seq(0, ncol(complete_cases))) +
  ggtitle("PCA Plot")
```

### PC 2 only

We also show PC2 on both axes.

```{r}
plot_pca(
  complete_cases, 2, 2, n = dim(complete_cases)[1], indicate = c("condition", "label"), label = TRUE
) +
  scale_shape_manual(values = seq(0, ncol(complete_cases))) +
  ggtitle("PCA Plot")
```

# Analysis

Because there are no replicates, conventional differential expression cannot be performed.
Instead we use various methods to analyse patterns and trends apparent in the dataset.

```{r}
color <- colorRamp2(
  c(
    min(assay(data), na.rm = TRUE),
    (max(assay(data), na.rm = TRUE) + min(assay(data), na.rm = TRUE)) / 2,
    max(assay(data), na.rm = TRUE)
  ),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
```

## PCA Loadings

PC1 appears to capture a linear relationship between proteins expressed and fraction from which it comes from.
The proteins driving this trend can be extracted from the PCA loadings.

```{r, fig.height = 10}
pca <- prcomp(t(assay(complete_cases)))
loadings <- pca$rotation
loadings <- loadings %>%
  tibble::as_tibble(rownames = "prot")

# Proteins with higher intensity in light fractions.
# --------------------------------------------------
top_PC_prot <- loadings %>%
  dplyr::select(prot, PC1) %>%
  tidyr::pivot_longer(matches("PC"), names_to = "PC", values_to = "loading") %>%
  dplyr::group_by(PC) %>%
  dplyr::arrange(loading) %>%
  dplyr::slice(1:50) %>%
  dplyr::pull(prot) %>%
  unique()
# --------------------------------------------------

datatable_download(data.frame(highest_in_light_frac = top_PC_prot))

draw(
  Heatmap(
    assay(complete_cases[top_PC_prot, ]),
    color,
    cluster_columns = FALSE,
    row_names_gp = gpar(fontsize = 10),
    heatmap_legend_param = list(title = "log2 Intensity", direction = "horizontal"),
    column_names_rot = 45,
    rect_gp = gpar(col = "black")
  ),
  heatmap_legend_side = "top"
)

# Proteins with higher intensity in heavy fractions.
# --------------------------------------------------
top_PC_prot <- loadings %>%
  dplyr::select(prot, PC1) %>%
  tidyr::pivot_longer(matches("PC"), names_to = "PC", values_to = "loading") %>%
  dplyr::group_by(PC) %>%
  dplyr::arrange(desc(loading)) %>%
  dplyr::slice(1:50) %>%
  dplyr::pull(prot) %>%
  unique()
# --------------------------------------------------

datatable_download(data.frame(highest_in_heavy_frac = top_PC_prot))

draw(
  Heatmap(
    assay(complete_cases[top_PC_prot, ]),
    color,
    cluster_columns = FALSE,
    row_names_gp = gpar(fontsize = 10),
    heatmap_legend_param = list(title = "log2 Intensity", direction = "horizontal"),
    column_names_rot = 45,
    rect_gp = gpar(col = "black")
  ),
  heatmap_legend_side = "top"
)
```

## Proteins of interest

### TAU and LRP1

We probe the expression of TAU (MAPT) and LRP1, two proteins we are particularly interested in.

```{r}
sub_data <- assay(data[rowData(data)$gene_names == "MAPT" | rowData(data)$gene_names == "LRP1", ])
datatable_download(sub_data)

draw(
  Heatmap(
    sub_data,
    color,
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    row_names_max_width = max_text_width(rownames(data)),
    heatmap_legend_param = list(title = "log2 Intensity", direction = "horizontal"),
    column_names_rot = 45,
    rect_gp = gpar(col = "black")
  ),
  heatmap_legend_side = "top"
)
```

## MISEV

```{r}
MISEV <- read.delim(file.path(assets_dir, data_name, "MISEV-curated-tidy.tsv"))
MISEV_groups <- read.delim(file.path(assets_dir, data_name, "MISEV-groups-trimmed.tsv"))

rownames(data)[which(rownames(data) == "PDCD6IP")] <- "ALIX"

keep <- c(
  "CD81", "CD63", "LAMP2", "CD9", "APP", "THY1",
  "ANXA1", "ANXA2", "ANXA6", "ANXA5", "ANXA4", "ANXA3", "ANXA7", "ANXA11",
  "MAPT", "FLOT", "ALIX",
  "ACTN4", "ACTN1", "ACTN2", "ACTR1B", "ACTB", "ACTR3", "ACTR2", "ACTR1A", "ACTG1", "ACTC1",
  "APOOL", "APOL2", "APOO", "APOB", "APOH", "APOE", "APOD",
  "LMNA", "LMNB2",
  "VDAC1", "VDAC2", "VDAC3",
  "GOLM1", "GOLM2",
  "EMC1", "EMC2", "EMC3", "EMC7", "EMC8",
  "ATG9A", "FGF1", "FGF2", "MFGE8"
)

tiers <- c(
  as.numeric(sub(".*:", "", summary(data.frame(c(assay(data))))))[2],
  as.numeric(sub(".*:", "", summary(data.frame(c(assay(data))))))[5]
)
tier_cutoff <-
  ((max(assay(data), na.rm = TRUE) - min(assay(data), na.rm = TRUE)) / 2) +
  min(assay(data), na.rm = TRUE)

min_10_perc <- min(assay(data), na.rm = TRUE) - (min(assay(data), na.rm = TRUE) * 0.1)
```

### Unaggregated, Including Proteins with All Missing, All Fractions, Full Intensity Heatmap

```{r, fig.height = 8, fig.width = 7}
proteins <- as.vector(unlist(MISEV))
proteins <- proteins[proteins != ""]
proteins <- trimws(proteins)
proteins <- proteins[proteins %in% keep]

sub_data <- assay(data[rownames(data) %in% proteins, ])

missing <- proteins[proteins %notin% rownames(sub_data)]
missing <- matrix(
  nrow = length(missing), ncol = ncol(sub_data), dimnames = list(missing, colnames(sub_data))
)
sub_data <- rbind(sub_data, missing)

remove <- trimws(unlist(MISEV)) %notin% rownames(sub_data)
proteins <- trimws(unlist(MISEV))
for (i in seq_along(remove)) {
  if (remove[i] == TRUE) {
    proteins[[i]] <- ""
  }
}
proteins <- proteins[proteins != ""]
categories <- names(proteins)
categories <- stri_extract(categories, regex = ".*[a-z]")
categories <- sub("^.*\\.", "", categories)

sub_data <- sub_data[match(proteins, rownames(sub_data)), ]
no_NA_data <- sub_data
no_NA_data[is.na(no_NA_data)] <- min_10_perc
prot_per_cat <- as.vector(table(categories))
row_counter <- 0
for (i in seq_along(unique(categories))) {
  order <- order(
    rowMeans(no_NA_data[(row_counter + 1):(prot_per_cat[i] + row_counter), , drop = FALSE])
  )
  order <- order + row_counter
  order <- sub_data[order, , drop = FALSE]
  sub_data <- sub_data[order(match(rownames(sub_data), rownames(order))), ]
  row_counter <- row_counter + prot_per_cat[i]
}
sub_data <- sub_data[rev(rownames(sub_data)), ]

datatable_download(sub_data)

draw(
  Heatmap(
    sub_data,
    color,
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    row_names_max_width = max_text_width(rownames(data)),
    heatmap_legend_param = list(title = "log2 Intensity", direction = "horizontal"),
    column_names_rot = 45,
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_split = colnames(sub_data),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    rect_gp = gpar(col = "black")
  ),
  heatmap_legend_side = "top"
)
```

### Unaggregated, Including Proteins with All Missing, All Fractions, 3 Tier Heatmap

```{r, fig.height = 8, fig.width = 7}
cat("Tier cutoff intensity:", tier_cutoff)

tiered_data <- sub_data
tiered_data[tiered_data <= tier_cutoff] <- 0
tiered_data[tiered_data > tier_cutoff] <- 1

datatable_download(tiered_data)

draw(
  Heatmap(
    tiered_data,
    brewer.pal(11, "RdYlBu")[c(9, 3)],
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    column_names_rot = 45,
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_split = colnames(tiered_data),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    show_heatmap_legend = FALSE,
    rect_gp = gpar(col = "black")
  )
)
draw(
  Heatmap(
    tiered_data,
    brewer.pal(11, "RdYlBu")[c(10, 2)],
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    column_names_rot = 45,
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_split = colnames(tiered_data),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    show_heatmap_legend = FALSE,
    rect_gp = gpar(col = "black")
  )
)
```

### Unaggregated, Including Proteins with All Missing, Combined Fractions, 3 Tier Heatmap

```{r, fig.height = 8, fig.width = 2}
combined_data <- sub_data
combined_data[is.na(combined_data)] <- min_10_perc
combined_data <- as.matrix(rowSums(combined_data))
colnames(combined_data) <- "combined_fractions"
combined_data[combined_data == min_10_perc * ncol(sub_data)] <- NA
combined_data <- combined_data / ncol(sub_data)

combined_data[combined_data <= tier_cutoff] <- 0
combined_data[combined_data > tier_cutoff] <- 1

datatable_download(combined_data)

draw(
  Heatmap(
    combined_data,
    brewer.pal(11, "RdYlBu")[c(9, 3)],
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    row_names_max_width = max_text_width(rownames(data)),
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    show_heatmap_legend = FALSE,
    show_column_names = FALSE,
    rect_gp = gpar(col = "black")
  )
)
draw(
  Heatmap(
    combined_data,
    brewer.pal(11, "RdYlBu")[c(10, 2)],
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    row_names_max_width = max_text_width(rownames(data)),
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    show_heatmap_legend = FALSE,
    show_column_names = FALSE,
    rect_gp = gpar(col = "black")
  )
)
```

### Aggregated, Including Proteins with All Missing, All Fractions, Full Intensity Heatmap

```{r, fig.height = 5, fig.width = 5}
proteins <- as.vector(unlist(MISEV))
proteins <- proteins[proteins != ""]
proteins <- trimws(proteins)
proteins <- proteins[proteins %in% keep]

sub_data <- assay(data[rownames(data) %in% proteins, ])

missing <- proteins[proteins %notin% rownames(sub_data)]
missing <- matrix(
  nrow = length(missing), ncol = ncol(sub_data), dimnames = list(missing, colnames(sub_data))
)
sub_data <- rbind(sub_data, missing)

remove <- trimws(unlist(MISEV)) %notin% rownames(sub_data)
proteins <- trimws(unlist(MISEV))
for (i in seq_along(remove)) {
  if (remove[i] == TRUE) {
    proteins[[i]] <- ""
  }
}
proteins <- proteins[proteins != ""]
categories <- names(proteins)
categories <- stri_extract(categories, regex = ".*[a-z]")
categories <- sub("^.*\\.", "", categories)
sub_data <- sub_data[match(proteins, rownames(sub_data)), ]

group_proteins <- as.vector(unlist(MISEV_groups))
group_proteins <- group_proteins[group_proteins != ""]
group_proteins <- trimws(group_proteins)

for (i in seq(ncol(MISEV_groups))) {
  idx_start <- which(rownames(sub_data) == trimws(MISEV_groups[1, i]))
  if (MISEV_groups[nrow(MISEV_groups), i] == "") {
    last_char <- min(which(MISEV_groups[ , i] == "")) - 1
    idx_end <- which(rownames(sub_data) == trimws(MISEV_groups[last_char, i]))
  } else {
    idx_end <- which(rownames(sub_data) == trimws(MISEV_groups[nrow(MISEV_groups), i]))
  }
  new_row <- matrix(ncol = ncol(sub_data))
  rownames(new_row) <- paste0(trimws(colnames(MISEV_groups)[i]), "*")
  proteins[proteins == trimws((MISEV_groups)[1, i])] <- trimws(colnames(MISEV_groups)[i])
  for (j in seq(ncol(sub_data))) {
    new_row[j] <- mean(sub_data[idx_start:idx_end, j], na.rm = TRUE)
  }
  sub_data <- sub_data[-(idx_start:idx_end), ]
  sub_data <- rbind(sub_data, new_row)
}

proteins <- proteins[proteins %in% sub("\\*", "", rownames(sub_data))]
categories <- names(proteins)
categories <- stri_extract(categories, regex = ".*[a-z]")
categories <- sub("^.*\\.", "", categories)
sub_data <- sub_data[match(proteins, sub("\\*", "", rownames(sub_data))), ]

no_NA_data <- sub_data
no_NA_data[is.na(no_NA_data)] <- min_10_perc
prot_per_cat <- as.vector(table(categories))
row_counter <- 0
for (i in seq_along(unique(categories))) {
  order <- order(
    rowMeans(no_NA_data[(row_counter + 1):(prot_per_cat[i] + row_counter), , drop = FALSE])
  )
  order <- order + row_counter
  order <- sub_data[order, , drop = FALSE]
  sub_data <- sub_data[order(match(rownames(sub_data), rownames(order))), ]
  row_counter <- row_counter + prot_per_cat[i]
}
sub_data <- sub_data[rev(rownames(sub_data)), ]

datatable_download(sub_data)

draw(
  Heatmap(
    sub_data,
    color,
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    row_names_max_width = max_text_width(rownames(data)),
    heatmap_legend_param = list(title = "log2 Intensity", direction = "horizontal"),
    column_names_rot = 45,
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_split = colnames(sub_data),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    rect_gp = gpar(col = "black")
  ),
  heatmap_legend_side = "top"
)
```

### Aggregated, Including Proteins with All Missing, All Fractions, 3 Tier Heatmap

```{r, fig.height = 5, fig.width = 5}
cat("Tier cutoff intensity:", tier_cutoff)

tiered_data <- sub_data
tiered_data[tiered_data <= tier_cutoff] <- 0
tiered_data[tiered_data > tier_cutoff] <- 1

datatable_download(tiered_data)

draw(
  Heatmap(
    tiered_data,
    brewer.pal(11, "RdYlBu")[c(9, 3)],
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    column_names_rot = 45,
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_split = colnames(tiered_data),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    show_heatmap_legend = FALSE,
    rect_gp = gpar(col = "black")
  )
)
draw(
  Heatmap(
    tiered_data,
    brewer.pal(11, "RdYlBu")[c(10, 2)],
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    column_names_rot = 45,
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_split = colnames(tiered_data),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    show_heatmap_legend = FALSE,
    rect_gp = gpar(col = "black")
  )
)
```

### Aggregated, Including Proteins with All Missing, Combined Fractions, 3 Tier Heatmap

```{r, fig.height = 5, fig.width = 2}
combined_data <- sub_data
combined_data[is.na(combined_data)] <- min_10_perc
combined_data <- as.matrix(rowSums(combined_data))
colnames(combined_data) <- "combined_fractions"
combined_data[combined_data == min_10_perc * ncol(sub_data)] <- NA
combined_data <- combined_data / ncol(sub_data)

combined_data[combined_data <= tier_cutoff] <- 0
combined_data[combined_data > tier_cutoff] <- 1

datatable_download(combined_data)

draw(
  Heatmap(
    combined_data,
    brewer.pal(11, "RdYlBu")[c(9, 3)],
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    row_names_max_width = max_text_width(rownames(data)),
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    show_heatmap_legend = FALSE,
    show_column_names = FALSE,
    rect_gp = gpar(col = "black")
  )
)
draw(
  Heatmap(
    combined_data,
    brewer.pal(11, "RdYlBu")[c(10, 2)],
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    row_names_max_width = max_text_width(rownames(data)),
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    show_heatmap_legend = FALSE,
    show_column_names = FALSE,
    rect_gp = gpar(col = "black")
  )
)
```

### Aggregated, Excluding Proteins with All Missing, All Fractions, Full Intensity Heatmap

```{r, fig.height = 5, fig.width = 5}
sub_data <- sub_data[rowSums(is.na(sub_data)) != ncol(sub_data), ]
proteins <- proteins[proteins %in% sub("\\*", "", rownames(sub_data))]
categories <- names(proteins)
categories <- stri_extract(categories, regex = ".*[a-z]")
categories <- sub("^.*\\.", "", categories)

no_NA_data <- sub_data
no_NA_data[is.na(no_NA_data)] <- min_10_perc
prot_per_cat <- as.vector(table(categories))
row_counter <- 0
for (i in seq_along(unique(categories))) {
  order <- order(
    rowMeans(no_NA_data[(row_counter + 1):(prot_per_cat[i] + row_counter), , drop = FALSE])
  )
  order <- order + row_counter
  order <- sub_data[order, , drop = FALSE]
  sub_data <- sub_data[order(match(rownames(sub_data), rownames(order))), ]
  row_counter <- row_counter + prot_per_cat[i]
}
sub_data <- sub_data[rev(rownames(sub_data)), ]

datatable_download(sub_data)

draw(
  Heatmap(
    sub_data,
    color,
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    row_names_max_width = max_text_width(rownames(data)),
    heatmap_legend_param = list(title = "log2 Intensity", direction = "horizontal"),
    column_names_rot = 45,
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_split = colnames(sub_data),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    rect_gp = gpar(col = "black")
  ),
  heatmap_legend_side = "top"
)
```

### Aggregated, Excluding Proteins with All Missing, All Fractions, 3 Tier Heatmap

```{r, fig.height = 5, fig.width = 5}
cat("Tier cutoff intensity:", tier_cutoff)

tiered_data <- sub_data
tiered_data[tiered_data <= tier_cutoff] <- 0
tiered_data[tiered_data > tier_cutoff] <- 1

datatable_download(tiered_data)

draw(
  Heatmap(
    tiered_data,
    brewer.pal(11, "RdYlBu")[c(9, 3)],
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    column_names_rot = 45,
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_split = colnames(tiered_data),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    show_heatmap_legend = FALSE,
    rect_gp = gpar(col = "black")
  )
)
draw(
  Heatmap(
    tiered_data,
    brewer.pal(11, "RdYlBu")[c(10, 2)],
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    column_names_rot = 45,
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_split = colnames(tiered_data),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    show_heatmap_legend = FALSE,
    rect_gp = gpar(col = "black")
  )
)
```

### Aggregated, Excluded Proteins with All Missing, Combined Fractions, 3 Tier Heatmap

```{r, fig.height = 5, fig.width = 2}
combined_data <- sub_data
combined_data[is.na(combined_data)] <- min_10_perc
combined_data <- as.matrix(rowSums(combined_data))
colnames(combined_data) <- "combined_fractions"
combined_data[combined_data == min_10_perc * ncol(sub_data)] <- NA
combined_data <- combined_data / ncol(sub_data)

combined_data[combined_data <= tier_cutoff] <- 0
combined_data[combined_data > tier_cutoff] <- 1

datatable_download(combined_data)

draw(
  Heatmap(
    combined_data,
    brewer.pal(11, "RdYlBu")[c(9, 3)],
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    row_names_max_width = max_text_width(rownames(data)),
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    show_heatmap_legend = FALSE,
    show_column_names = FALSE,
    rect_gp = gpar(col = "black")
  )
)
draw(
  Heatmap(
    combined_data,
    brewer.pal(11, "RdYlBu")[c(10, 2)],
    na_col = "#DDDDDD",
    cluster_columns = FALSE,
    cluster_rows = FALSE,
    row_names_max_width = max_text_width(rownames(data)),
    row_split = categories,
    row_title_rot = 0,
    row_gap = unit(2, "mm"),
    column_gap = unit(0, "mm"),
    border = TRUE,
    column_title = NULL,
    row_names_gp = gpar(fontsize = 9),
    show_heatmap_legend = FALSE,
    show_column_names = FALSE,
    rect_gp = gpar(col = "black")
  )
)
```

## LOPIT

```{r}
data(thpLOPIT_unstimulated_mulvey2021)
mulvey2021 <- thpLOPIT_unstimulated_mulvey2021
rm(thpLOPIT_unstimulated_mulvey2021)

markers <- data.frame(gene = fData(mulvey2021)$GN, organelle = fData(mulvey2021)$markers)
markers <- markers[-which(is.na(markers)), ]
markers <- markers[order(markers$organelle), ]
datatable_download(markers)

gene_sets <- getGmt(file.path(assets_dir, "gene-sets", "LOPIT-markers.gmt"))
gsva <- gsva(assay(data), gene_sets, method = "zscore", verbose = FALSE)
datatable_download(gsva)

gsva_color <- colorRamp2(
  c(min(gsva), (max(gsva) + min(gsva)) / 2, max(gsva)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
draw(
  Heatmap(
    gsva,
    gsva_color,
    cluster_columns = FALSE,
    row_names_gp = gpar(fontsize = 10),
    heatmap_legend_param = list(title = "Z-score enrichment", direction = "horizontal"),
    column_names_rot = 45,
    rect_gp = gpar(col = "black")
  ),
  heatmap_legend_side = "top"
)
```

# References

This is the concluding section of the document, where we output the `sessionInfo`, and create a bibliography for works cited.

```{r}
sessionInfo()
```
