---
title: "Combined AD CTRL"
author:
  - name: "Emir, Pal, and Steph"
date: '`r strftime(Sys.time(), "%B %d, %Y")`'
bibliography: "../AD-CBD-exosome-proteins.bib"
link-citations: true
output:
  html_document:
    code_folding: hide
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(
    "..", "results", "combined-AD-CTRL.html"
  ))})
---

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
.tocify-subheader .tocify-subheader .tocify-item {
  font-size: 0.95em; padding-left: 35px; text-indent: 0;
}
div.main-container {max-width: none; width: 100%;}
</style>

*This file is a part of [AD-CBD-exosome-proteins](https://github.com/eturkes/AD-CBD-exosome-proteins).*
*Please email me for access.*

The data here will be referenced using the name `combined`.
It is a merged dataset of two proteomics runs done in January and in March.
The data included here are label-free mass spec on exosomes derived from matched AD and control samples.

```{r}
# Some standard boilerplate.
# --------------------------
# Copyright 2019-2020 Emir Turkes, Guar Pallavi, Stephanie Fowler, UK DRI at UCL, Columbia
# University Medical Center
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This section should be checked per document.
# --------------------------------------------
options(stringsAsFactors = FALSE)
packages <- c(
  "conflicted", "circlize", "dplyr", "DEP", "SummarizedExperiment", "scales", "ggplot2",
  "DT", "ComplexHeatmap", "EnhancedVolcano", "GSEABase", "GSVA", "RColorBrewer", "limma"
)
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))
source(file.path(getwd(), "utils.R"))
conflict_prefer("rowMedians", "Biobase", quiet = TRUE)
conflict_prefer("which", "BiocGenerics", quiet = TRUE)
conflict_prefer("select", "dplyr", quiet = TRUE)

data_name <- "combined"
`%notin%` <- Negate(`%in%`)
# --------------------------------------------

# Everything else in this chunk remains generally unchanged.
# ----------------------------------------------------------
assets_dir <- file.path(getwd(), "..", "assets") # Backed up data.

cache_dir <- file.path(getwd(), "..", "tmp", "cache", data_name)
if (!dir.exists(cache_dir)) {
  dir.create(cache_dir, recursive = TRUE)
}

knitr::opts_chunk$set(fig.width = 10, fig.height = 7)
# ----------------------------------------------------------
# --------------------------
```

# No Outlier Removal

In this section we look at all of the data without any removal of possible outlier samples.

## Prep

Read in the data and organize into a `SummarizedExperiment` object.

```{r}
# Read in data.
# -------------
data <- read.csv(file.path(assets_dir, data_name, "data_comb_steph.csv"))
design <- read.delim(file.path(assets_dir, data_name, "metadata.tsv"))
# -------------

# Add additional info to metadata.
# --------------------------------
design$replicate <- c(seq(9), seq(8))
design$bio_rep <- c(
  "AD_5333", "AD_5365", "AD_5398", "AD_5475", "AD_5475", "AD_5475", "AD_5521", "AD_5521", "AD_5521",
  "CTRL_159", "CTRL_4070", "CTRL_4070", "CTRL_4070", "CTRL_5382", "CTRL_328", "CTRL_328", "CTRL_328"
)
design$sample <- as.factor(design$sample)
# --------------------------------

# Clean up data and subset to the minimum necessary info.
# -------------------------------------------------------
data <- make_unique(data, "Gene.names", "Protein.IDs.x", ";")
keep <- grep("Intensity.", colnames(data)) # Get LFQ intensities.
data_minimal <- data[ , keep]
colnames(data_minimal) <- c(
  "AD_5475_jan", "AD_5475_jan2", "AD_5521_jan", "AD_5521_jan2", "CTRL_328_jan",
  "CTRL_328_jan2", "CTRL_4070_jan", "CTRL_4070_jan2", "AD_5333_mar", "AD_5365_mar_levy",
  "AD_5398_mar", "AD_5475_mar", "AD_5521_mar", "CTRL_159_mar", "CTRL_328_mar",
  "CTRL_4070_mar", "CTRL_5382_mar"
)
data_minimal <- data_minimal[ , order(match(colnames(data_minimal), design$label))]
data_minimal <- cbind(data_minimal, data[ , c((ncol(data) - 1):ncol(data))])
# -------------------------------------------------------

# Make SE object and differentiate between long and short versions of the column names.
# -------------------------------------------------------------------------------------
data <- make_se(data_minimal, seq(nrow(design)), design)
short_names <- colnames(data) # "AD_1" etc.
long_names <- colnames(data_minimal)[seq(nrow(design))] # "AD_5475_jan" etc.
rm(data_minimal)
colnames(data) <- long_names
# -------------------------------------------------------------------------------------

# Create heatmap metadata.
# ------------------------
bio_rep_color <- hue_pal()(length(unique(design$bio_rep)))
top_anno <- HeatmapAnnotation(
  biological_replicate = design$bio_rep,
  sex = design$sex,
  month = design$month,
  col = list(
    biological_replicate = c(
      "AD_5333" = bio_rep_color[1], "AD_5365" = bio_rep_color[3],
      "AD_5398" = bio_rep_color[5], "AD_5475" = bio_rep_color[7],
      "AD_5521" = bio_rep_color[9], "CTRL_159" = bio_rep_color[2],
      "CTRL_4070" = bio_rep_color[4], "CTRL_5382" = bio_rep_color[6],
      "CTRL_328" = bio_rep_color[8]
    ),
    sex = c("M" = bio_rep_color[1], "F" = bio_rep_color[7]),
    month = c("March" = bio_rep_color[1], "Jan" = bio_rep_color[7])
  ),
  annotation_legend_param = list(
    biological_replicate = list(title_position = "leftcenter-rot"),
    sex = list(title_position = "leftcenter-rot"),
    month = list(title_position = "leftcenter-rot")
  )
)
# ------------------------

data
```

**Unaltered data, already log2 transformed**

```{r}
datatable_download(assay(data))
```

**After removal of log transformation**

```{r}
datatable_download(2 ^ assay(data))
```

## QC

We apply quality control to the data.

### Summary Statistics

Basic descriptions of the data such as distributions.
For now we just have a histogram.

```{r}
hist(assay(data), n = 100)
```

### Missing Value Removal

Here we remove proteins with too many missing values and mark those that are missing-not-at-random (MNAR) and missing-at-random (MAR) for imputation later.
The basic workflow is shown below:

![](../assets/figures/missing-value-removal.svg)

```{r}
# Step 1 in flowchart.
# Remove proteins missing entirely in one condition.
# --------------------------------------------------
discard <- which(is.na(rowMeans(assay(data)[ , 1:ceiling(ncol(data) / 2)], TRUE)))
data <- data[-discard, ]
discard <- which(is.na(rowMeans(assay(data)[ , (ceiling(ncol(data) / 2) + 1):ncol(data)], TRUE)))
data <- data[-discard, ]
# --------------------------------------------------

complete_cases <- filter_proteins(data, "complete") # Keep another object with only complete values.

colnames(data) <- short_names # Below function doesn't currently work with `long_names`.
plot_numbers(data)
colnames(data) <- long_names
plot_frequency(data)
plot_detect(data)
```

```{r, fig.height = 100}
# Steps 2 and 3 in flowchart.
# Order each condition by row means and select the last protein to be included as MNAR.
# We choose row means over medians because high expression outliers may be decent indication a
# protein is not MNAR.
# --------------------------------------------------------------------------------------------
AD_order <- order(rowMeans(assay(data)[ , 1:ceiling(ncol(data) / 2)], TRUE))
data <- data[AD_order, ]
AD_MNAR <- rownames(data)[1:which(rownames(data) == "ATRN")] # TODO: Automate this.
plot_missval_custom(data)

Control_order <- order(rowMeans(assay(data)[ , (ceiling(ncol(data) / 2) + 1):ncol(data)], TRUE))
data <- data[Control_order, ]
Control_MNAR <- rownames(data)[1:which(rownames(data) == "PREP")] # TODO: Automate this.
plot_missval_custom(data)
# --------------------------------------------------------------------------------------------

# Step 4 in flowchart.
# In each condition, remove MAR (non-MNAR) proteins where the majority are missing.
# This has not been empirically tested, but we have found that MAR imputation with a majority of
# missing values leads to suspect imputation.
# MNAR imputation however, does not suffer from this limitation, and in fact it is logical that MNAR
# proteins would have a high number of missing values.
# --------------------------------------------------------------------------------------------------
AD_data <- data[ , 1:ceiling(ncol(data) / 2)]
AD_data <- AD_data[rownames(AD_data) %notin% AD_MNAR, ]
missing_data <- assay(AD_data) %>% data.frame(.)
missing_data <- ifelse(is.na(missing_data), 0, 1)
discard <- which(rowSums(missing_data, TRUE) < 5) # TODO: Automate this.
AD_data <- AD_data[-discard, ]
print(paste0("Removed ", length(discard), " proteins from AD group."))

Control_data <- data[ , (ceiling(ncol(data) / 2) + 1):ncol(data)]
Control_data <- Control_data[rownames(Control_data) %notin% Control_MNAR, ]
missing_data <- assay(Control_data) %>% data.frame(.)
missing_data <- ifelse(is.na(missing_data), 0, 1)
discard <- which(rowSums(missing_data, TRUE) < 5) # TODO: Automate this.
Control_data <- Control_data[-discard, ]
print(paste0("Removed ", length(discard), " proteins from Control group."))
# --------------------------------------------------------------------------------------------------

# Continuation of step 4 in flowchart.
# In order to ensure that all conditions have MAR proteins with majority non-missing values, we
# perform the unions below.
# For example, out of the proteins that pass this QC in the AD condition, or have no missing values,
# we only keep those that pass this QC, have no missing values, or are MNAR in the Control condition
# as well.
# --------------------------------------------------------------------------------------------------
AD_MAR <- rownames(AD_data)[
  rownames(AD_data) %in% Control_MNAR | rownames(AD_data) %in% rownames(Control_data)
]
Control_MAR <- rownames(Control_data)[
  rownames(Control_data) %in% AD_MNAR | rownames(Control_data) %in% rownames(AD_data)
]
rm(AD_data, Control_data)
MAR <- unique(append(AD_MAR, Control_MAR)) # Note that complete proteins are also in here.

AD_MNAR_passQC <- AD_MNAR[AD_MNAR %in% Control_MAR | AD_MNAR %in% Control_MNAR]
Control_MNAR_passQC <- Control_MNAR[Control_MNAR %in% AD_MAR | Control_MNAR %in% AD_MNAR]
MNAR <- unique(append(AD_MNAR_passQC, Control_MNAR_passQC))
# --------------------------------------------------------------------------------------------------

# Step 5 (last step) in flowchart.
# We join MAR and MNAR lists and subset the data.
# -----------------------------------------------
keep <- unique(append(MAR, MNAR))
data <- data[rownames(data) %in% keep, ]
# -----------------------------------------------

# Save some orders/subsets for later use.
# ---------------------------------------
data <- data[sort(rownames(data)), ]
AD_order <- order(rowMeans(assay(data)[ , 1:ceiling(ncol(data) / 2)], TRUE))
Control_order <- order(rowMeans(assay(data)[ , (ceiling(ncol(data) / 2) + 1):ncol(data)], TRUE))
missing_data <- assay(data) %>% data.frame(.)
missing_data <- missing_data[apply(missing_data, 1, function(x) any(is.na(x))), ]
# ---------------------------------------
```

```{r}
colnames(data) <- short_names # Below function doesn't currently work with `long_names`.
plot_numbers(data)
colnames(data) <- long_names
plot_frequency(data)
plot_detect(data)
```

**Data before normalization but after removal of missing values**

```{r}
datatable_download(assay(data))
```

**Complete cases before normalization but after removal of missing values**

```{r}
datatable_download(assay(complete_cases))
```

### Normalization

Here we perform VSN normalization, but also include some output from NormalyzerDE web tool [@willforssNormalyzerDEOnlineTool2019] ([http://130.235.214.136/](http://130.235.214.136/)) for evaulating the performance of various normalization methods (note that these figures were only generated without outlier removal).

```{r}
# Export data without log transformation for NormalyzerDE.
# --------------------------------------------------------
write.table(
  cbind(rownames(data), 2 ^ assay(data)), file.path(cache_dir, "data_assay.tsv"), quote = FALSE,
  row.names = FALSE, sep = "\t"
)
# --------------------------------------------------------

# Normalize using VSN.
# We also create several extra variables for better plotting labels.
# ------------------------------------------------------------------
colnames(data) <- short_names
VSN_Normalized <- normalize_vsn(data)
Log_Transform_Only <- data

colnames(complete_cases) <- short_names
VSN_Normalized_Non_Missing_Data <- normalize_vsn(complete_cases)
Log_Transform_Only_Non_Missing_Data <- complete_cases
# ------------------------------------------------------------------

# Display results of normalization.
# ---------------------------------
print("Log_Transform_Only")
meanSdPlot(Log_Transform_Only)
print("Log_Transform_Only_Non_Missing_Data")
meanSdPlot(Log_Transform_Only_Non_Missing_Data)
print("VSN_Normalized")
meanSdPlot(VSN_Normalized)
print("VSN_Normalized_Non_Missing_Data")
meanSdPlot(VSN_Normalized_Non_Missing_Data)

plot_normalization(Log_Transform_Only, VSN_Normalized)
plot_normalization(Log_Transform_Only_Non_Missing_Data, VSN_Normalized_Non_Missing_Data)
# ---------------------------------

# Move normalized data to main objects and clean up.
# --------------------------------------------------
data <- VSN_Normalized
complete_cases <- VSN_Normalized_Non_Missing_Data
rm(
  VSN_Normalized, VSN_Normalized_Non_Missing_Data,
  Log_Transform_Only, Log_Transform_Only_Non_Missing_Data
)
# --------------------------------------------------
```

**Boxplots from NormalyzerDE**
![](../assets/combined/normalization-boxplots.png)

**RLE plots from NormalyzerDE**
![](../assets/combined/normalization-RLE.png)

**Data after normalization and log2 transformation**

```{r}
datatable_download(assay(data))
```

### Missing Value Imputation

Here we impute missing values using both MAR (`knn`) and MNAR methods (`MinProb`).
We also apply this combo separately for each condition as each condition has their own MNAR cutoffs.

```{r}
# We create several extra variables for better plotting labels.
# -------------------------------------------------------------
unimputed_data <- data
Unimputed_Data <- unimputed_data
Non_Missing_data <- complete_cases
# -------------------------------------------------------------

plot_imputation(Unimputed_Data, Non_Missing_data)

# The main imputation code.
# -------------------------
impute1 <- data[ , 1:ceiling(ncol(data) / 2)]
impute_vector <- rownames(impute1) %in% AD_MNAR_passQC # Logical vector specifying MNAR.
set.seed(1)
impute1 <- impute(impute1, "mixed", randna = !impute_vector, mar = "knn", mnar = "MinProb")

impute2 <- data[ , (ceiling(ncol(data) / 2) + 1):ncol(data)]
impute_vector <- rownames(impute2) %in% Control_MNAR_passQC # Logical vector specifying MNAR.
set.seed(1)
impute2 <- impute(impute2, "mixed", randna = !impute_vector, mar = "knn", mnar = "MinProb")
# -------------------------

# Move imputed data to main objects and clean up.
# -----------------------------------------------
Imputed_Data <- data
assay(Imputed_Data) <- cbind(assay(impute1), assay(impute2))
rm(impute1, impute2, Non_Missing_data)
data <- Imputed_Data
# -----------------------------------------------

plot_imputation(Imputed_Data)
```

```{r, fig.height = 100}
colnames(data) <- long_names
colnames(complete_cases) <- long_names

# Assess the imputation using heatmaps similar to those when performing missing value removal,
# heatmaps sorted by rowMeans (before imputation) for each condition.
# These heatmaps intend to be directly comparable with those, though this approach may be revised
# due to slighly different values from normalization and the colorscale.
# -----------------------------------------------------------------------------------------------
color <- colorRamp2(
  c(min(assay(data)), (max(assay(data)) + min(assay(data))) / 2, max(assay(data))),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)

data <- data[sort(rownames(data)), ]
data <- data[AD_order, ]
heatmap_data <- data[rownames(data) %in% rownames(missing_data), ]
Heatmap(
  assay(heatmap_data),
  color,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  cluster_rows = FALSE,
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16)
)

data <- data[sort(rownames(data)), ]
data <- data[Control_order, ]
heatmap_data <- data[rownames(data) %in% rownames(missing_data), ]
Heatmap(
  assay(heatmap_data),
  color,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  cluster_rows = FALSE,
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16)
)
# -----------------------------------------------------------------------------------------------
```

```{r}
# Create a few more plots.
# ------------------------
plot_normalization(Unimputed_Data, Imputed_Data)

print("Unimputed Data")
meanSdPlot(Unimputed_Data)
print("Imputed Data")
meanSdPlot(Imputed_Data)
# ------------------------

rm(Imputed_Data, Unimputed_Data)
```

**Data after missing value imputation**
**This is final form used for differential expression analysis**

```{r}
datatable_download(assay(data))
```

### PCA

Principal component analysis using all proteins in dataset.

```{r}
colnames(data) <- short_names # Below function doesn't currently work with `long_names`.
plot_pca(data, n = dim(data)[1], indicate = c("condition", "label"), label = TRUE) +
  scale_shape_manual(values = seq(0, ncol(data))) +
  ggtitle("PCA Plot")
colnames(data) <- long_names
```

### Variance Partitioning

We use the `variancePartition` and `ExploreModelMatrix` packages to quantify and interpret drivers of variation.
Note that for now we just paste images from the `ExploreModelMatrix` Shiny app (also note that they were only generated without outlier removal).

**All covariates**

```{r}
formula <- formula <- ~ (1|sex) + (1|month) + (1|condition) + age
var_part <- suppressWarnings(
  variancePartition::fitExtractVarPartModel(
    assay(data), formula, design, useWeights = FALSE, quiet = TRUE
  )
)
var_part <- variancePartition::sortCols(var_part)

variancePartition::plotPercentBars(var_part[1:10, ])
variancePartition::plotVarPart(var_part)
```

![](../assets/combined/design-vif.png)

![](../assets/combined/design-corr.png)

## Differential Expression

Here we test for differential expression using `limma` (currently through the `DEP` package) and plot the results.
We filter using a log2 fold change cutoff of 1 and a 0.05 p-value cutoff after BH multiple testing correction.
We also take into account technical replicates and covariates/random effects with low VIF, in this case, sex and age.

```{r}
# Perform the DE testing.
# -----------------------
data_results <- add_rejections(
  test_diff_custom(data, "control", "Control", design_formula = ~ 0 + condition + sex + month)
)
results <- get_results(data_results)
sig <- results[results$significant, ]
print(paste0(nrow(sig), " significant proteins."))
datatable_download(results)
# -----------------------
```

### Scaled Batch-corrected Heatmaps

```{r}
design_formula <- model.matrix(~ 0 + design$condition)
corr_fit <- duplicateCorrelation(assay(data), design_formula, block = design$sample)
corrected_data <- removeBatchEffect(
  assay(data), design$sex, design$month,
  design = model.matrix(~ 0 + design$condition), block = design$sample, cor = corr_fit$consensus
)
```

**With metadata removed**

```{r}
heatmap_data <- corrected_data
colnames(heatmap_data) <- design$sample
heatmap_data <- avearrays(heatmap_data)
heatmap_data <- t(scale(t(heatmap_data[rownames(heatmap_data) %in% sig$name, ])))
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  color2,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  column_split = c(rep("AD", 5), rep("Control", 4)),
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Scaled log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16),
)
```

**Full metadata**

```{r}
heatmap_data <- t(scale(t(corrected_data[rownames(corrected_data) %in% sig$name, ])))
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  color2,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Scaled log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16),
)
```

### Unscaled Heatmap

```{r}
heatmap_data <- assay(data)[rownames(data) %in% sig$name, ]
Heatmap(
  heatmap_data,
  color,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16),
)
```

### Johnson 2020 Module Proteins

We take a look at proteins within certain modules from [@johnsonLargescaleProteomicAnalysis2020].
All heatmaps are scaled and batch-corrected.
No new statistical tests are performed here, we use results from the differential expression section above.

**M1-synapse (54% matching)**

```{r}
module <- read.delim(file.path(assets_dir, data_name, "johnson-synapse-matching.tsv"), FALSE)
datatable_download(results[results$name %in% module$V1, ])
```

**Heatmap with metadata removed**

```{r}
heatmap_data <- corrected_data
colnames(heatmap_data) <- design$sample
heatmap_data <- avearrays(heatmap_data)
heatmap_data <- heatmap_data[rownames(heatmap_data) %in% module$V1, ]
heatmap_data <- t(scale(t(heatmap_data[rownames(heatmap_data) %in% sig$name, ])))
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  color2,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  column_split = c(rep("AD", 5), rep("Control", 4)),
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Scaled log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16),
)
```

**Heatmap with full metadata**

```{r}
heatmap_data <- corrected_data[rownames(corrected_data) %in% module$V1, ]
heatmap_data <- t(scale(t(heatmap_data[rownames(heatmap_data) %in% sig$name, ])))
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  color2,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Scaled log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16),
)
```

**Volcano plot**

```{r}
volcano_data <- results[results$name %in% module$V1, ]
EnhancedVolcano(
  volcano_data,
  volcano_data$name,
  "AD_vs_Control_ratio",
  "AD_vs_Control_p.adj",
  ylim = c(0, ceiling(max(-log10(volcano_data$AD_vs_Control_p.adj)))),
  xlab = bquote(~log[2]~"fold change"),
  ylab = bquote(~-log[10]~"adjusted p-value"),
  subtitle = NULL,
  caption = NULL,
  pCutoff = 0.05,
  cutoffLineType = "dotted",
  col = c(
    "grey80", brewer.pal(9, "RdYlBu")[3], brewer.pal(9, "RdYlBu")[3], brewer.pal(9, "RdYlBu")[1]
  ),
  legendLabels = c(
    "No thesholds passed", expression("|"~log[2]~"fold change |" > 1),
    expression("p-value" < 0.05), "Both thresholds passed"
  ),
  legendPosition = "bottom",
  legendDropLevels = FALSE,
  drawConnectors = TRUE,
  arrowheads = FALSE
) + ggtitle("M1-synapse proteins") +
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_text(
    data = data.frame(),
    aes(
      x = c(Inf, -Inf),
      y = c(-Inf, -Inf),
      hjust = c(1, 0),
      vjust = c(-1, -1),
      label = c("AD", " Control"),
      size = 5,
      fontface = "bold")
    )
```

**M3-mitochondrial (55% matching)**

```{r}
module <- read.delim(file.path(assets_dir, data_name, "johnson-mito-matching.tsv"), FALSE)
datatable_download(results[results$name %in% module$V1, ])
```

**Heatmap with metadata removed**

```{r}
heatmap_data <- corrected_data
colnames(heatmap_data) <- design$sample
heatmap_data <- avearrays(heatmap_data)
heatmap_data <- heatmap_data[rownames(heatmap_data) %in% module$V1, ]
heatmap_data <- t(scale(t(heatmap_data[rownames(heatmap_data) %in% sig$name, ])))
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  color2,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  column_split = c(rep("AD", 5), rep("Control", 4)),
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Scaled log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16),
)
```

**Heatmap with full metadata**

```{r}
heatmap_data <- corrected_data[rownames(corrected_data) %in% module$V1, ]
heatmap_data <- t(scale(t(heatmap_data[rownames(heatmap_data) %in% sig$name, ])))
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  color2,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Scaled log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16),
)
```

**Volcano plot**

```{r}
volcano_data <- results[results$name %in% module$V1, ]
EnhancedVolcano(
  volcano_data,
  volcano_data$name,
  "AD_vs_Control_ratio",
  "AD_vs_Control_p.adj",
  ylim = c(0, ceiling(max(-log10(volcano_data$AD_vs_Control_p.adj)))),
  xlab = bquote(~log[2]~"fold change"),
  ylab = bquote(~-log[10]~"adjusted p-value"),
  subtitle = NULL,
  caption = NULL,
  pCutoff = 0.05,
  cutoffLineType = "dotted",
  col = c(
    "grey80", brewer.pal(9, "RdYlBu")[3], brewer.pal(9, "RdYlBu")[3], brewer.pal(9, "RdYlBu")[1]
  ),
  legendLabels = c(
    "No thesholds passed", expression("|"~log[2]~"fold change |" > 1),
    expression("p-value" < 0.05), "Both thresholds passed"
  ),
  legendPosition = "bottom",
  legendDropLevels = FALSE,
  drawConnectors = TRUE,
  arrowheads = FALSE
) + ggtitle("M3-mitochondrial proteins") +
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_text(
    data = data.frame(),
    aes(
      x = c(Inf, -Inf),
      y = c(-Inf, -Inf),
      hjust = c(1, 0),
      vjust = c(-1, -1),
      label = c("AD", " Control"),
      size = 5,
      fontface = "bold")
    )
```

**M4-sugar-metabolism (42.5% matching)**

```{r}
module <- read.delim(file.path(assets_dir, data_name, "johnson-sugar-matching.tsv"), FALSE)
datatable_download(results[results$name %in% module$V1, ])
```

**Heatmap with metadata removed**

```{r}
heatmap_data <- corrected_data
colnames(heatmap_data) <- design$sample
heatmap_data <- avearrays(heatmap_data)
heatmap_data <- heatmap_data[rownames(heatmap_data) %in% module$V1, ]
heatmap_data <- t(scale(t(heatmap_data[rownames(heatmap_data) %in% sig$name, ])))
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  color2,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  column_split = c(rep("AD", 5), rep("Control", 4)),
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Scaled log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16),
)
```

**Heatmap with full metadata**

```{r}
heatmap_data <- corrected_data[rownames(corrected_data) %in% module$V1, ]
heatmap_data <- t(scale(t(heatmap_data[rownames(heatmap_data) %in% sig$name, ])))
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  color2,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Scaled log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16),
)
```

**Volcano plot**

```{r}
volcano_data <- results[results$name %in% module$V1, ]
EnhancedVolcano(
  volcano_data,
  volcano_data$name,
  "AD_vs_Control_ratio",
  "AD_vs_Control_p.adj",
  ylim = c(0, ceiling(max(-log10(volcano_data$AD_vs_Control_p.adj)))),
  xlab = bquote(~log[2]~"fold change"),
  ylab = bquote(~-log[10]~"adjusted p-value"),
  subtitle = NULL,
  caption = NULL,
  pCutoff = 0.05,
  cutoffLineType = "dotted",
  col = c(
    "grey80", brewer.pal(9, "RdYlBu")[3], brewer.pal(9, "RdYlBu")[3], brewer.pal(9, "RdYlBu")[1]
  ),
  legendLabels = c(
    "No thesholds passed", expression("|"~log[2]~"fold change |" > 1),
    expression("p-value" < 0.05), "Both thresholds passed"
  ),
  legendPosition = "bottom",
  legendDropLevels = FALSE,
  drawConnectors = TRUE,
  arrowheads = FALSE
) + ggtitle("M4-sugar-metabolism proteins") +
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_text(
    data = data.frame(),
    aes(
      x = c(Inf, -Inf),
      y = c(-Inf, -Inf),
      hjust = c(1, 0),
      vjust = c(-1, -1),
      label = c("AD", " Control"),
      size = 5,
      fontface = "bold")
    )
```

### Other Figures

```{r}
EnhancedVolcano(
  results,
  results$name,
  "AD_vs_Control_ratio",
  "AD_vs_Control_p.adj",
  ylim = c(0, ceiling(max(-log10(results$AD_vs_Control_p.adj)))),
  xlab = bquote(~log[2]~"fold change"),
  ylab = bquote(~-log[10]~"adjusted p-value"),
  subtitle = NULL,
  caption = NULL,
  pCutoff = 0.05,
  cutoffLineType = "dotted",
  col = c(
    "grey80", brewer.pal(9, "RdYlBu")[3], brewer.pal(9, "RdYlBu")[3], brewer.pal(9, "RdYlBu")[1]
  ),
  legendLabels = c(
    "No thesholds passed", expression("|"~log[2]~"fold change |" > 1),
    expression("p-value" < 0.05), "Both thresholds passed"
  ),
  legendPosition = "bottom",
  legendDropLevels = FALSE,
  drawConnectors = TRUE,
  arrowheads = FALSE
) + ggtitle("All proteins") +
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_text(
    data = data.frame(),
    aes(
      x = c(Inf, -Inf),
      y = c(-Inf, -Inf),
      hjust = c(1, 0),
      vjust = c(-1, -1),
      label = c("AD", " Control"),
      size = 5,
      fontface = "bold")
    )

plot_cor(data_results, pal = "RdBu", pal_rev = TRUE)
colnames(data_results) <- short_names
plot_single(data_results, sig$name, "centered") + xlab(element_blank())
colnames(data_results) <- long_names
```

**Proteins DE without multiple correction testing**

```{r, fig.height = 30}
no_mult_testing <- results[results$AD_vs_Control_p.val < 0.05, ]
no_mult_testing <- data_results[rownames(data_results) %in% no_mult_testing$name, ]
Heatmap(
  assay(no_mult_testing),
  color,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16)
)
```

**Imputed proteins DE without multiple correction testing**

```{r, fig.height = 30}
missing_no_mult_testing <- no_mult_testing[rownames(no_mult_testing) %in% rownames(missing_data), ]
missing_no_mult_testing <- missing_no_mult_testing[sort(rownames(missing_no_mult_testing)), ]
heatmap <- Heatmap(
  assay(missing_no_mult_testing),
  color,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16)
)
draw(heatmap)
```

**Proteins from above but without imputed values filled in**

```{r, fig.height = 30}
unimputed_missing_no_mult_testing <- unimputed_data[
  rownames(unimputed_data) %in% rownames(missing_no_mult_testing),
]
unimputed_missing_no_mult_testing <- unimputed_missing_no_mult_testing[
  sort(rownames(unimputed_missing_no_mult_testing)),
]
Heatmap(
  assay(unimputed_missing_no_mult_testing),
  color,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_order = row_order(heatmap),
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16)
)

rm(unimputed_missing_no_mult_testing, missing_no_mult_testing)
```

## Non-missing Data

We perform similar procedures as above but now only using a matrix of proteins that did not require any imputation.

### PCA

Principal component analysis using all proteins in dataset.

```{r}
colnames(complete_cases) <- short_names # Below function doesn't currently work with `long_names`.
plot_pca(
  complete_cases, n = dim(complete_cases)[1], indicate = c("condition", "label"), label = TRUE
  ) + scale_shape_manual(values = seq(0, ncol(data))) +
  ggtitle("PCA Plot")
colnames(complete_cases) <- long_names
```

### Differential Expression

Here we test for differential expression using `limma` (currently through the `DEP` package) and plot the results.
We filter using a log2 fold change cutoff of 1 and a 0.05 p-value cutoff after BH multiple testing correction.
We also take into account technical replicates and covariates/random effects with low VIF, in this case, sex and age.

```{r}
# Perform the DE testing.
# -----------------------
complete_results <- add_rejections(
  test_diff_custom(
    complete_cases, "control", "Control", design_formula = formula(~ 0 + condition + sex + month)
  )
)
results <- get_results(complete_results)
sig <- results[results$significant, ]
print(paste0(nrow(sig), " significant proteins."))
# -----------------------
```

**Scaled batch-corrected heatmap**

```{r}
design_formula <- model.matrix(~ 0 + design$condition)
corr_fit <- duplicateCorrelation(assay(complete_results), design_formula, block = design$sample)
corrected_data <- removeBatchEffect(
  assay(complete_results), design$sex, design$month,
  design = model.matrix(~ 0 + design$condition), block = design$sample, cor = corr_fit$consensus
)
heatmap_data <- t(scale(t(corrected_data[rownames(corrected_data) %in% sig$name, ])))
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  color2,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Scaled log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16),
)
```

**Unscaled heatmap**

```{r}
heatmap_data <- assay(complete_cases)[rownames(complete_cases) %in% sig$name, ]
Heatmap(
  heatmap_data,
  color,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16),
)
```

**Other figures**

```{r}
EnhancedVolcano(
  results,
  results$name,
  "AD_vs_Control_ratio",
  "AD_vs_Control_p.adj",
  ylim = c(0, ceiling(max(-log10(results$AD_vs_Control_p.adj)))),
  xlab = bquote(~log[2]~"fold change"),
  ylab = bquote(~-log[10]~"adjusted p-value"),
  subtitle = NULL,
  caption = NULL,
  pCutoff = 0.05,
  cutoffLineType = "dotted",
  col = c(
    "grey80", brewer.pal(9, "RdYlBu")[3], brewer.pal(9, "RdYlBu")[3], brewer.pal(9, "RdYlBu")[1]
  ),
  legendLabels = c(
    "No thesholds passed", expression("|"~log[2]~"fold change |" > 1),
    expression("p-value" < 0.05), "Both thresholds passed"
  ),
  legendPosition = "bottom",
  legendDropLevels = FALSE,
  drawConnectors = TRUE,
  arrowheads = FALSE
) + ggtitle("All non-missing proteins") +
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_text(
    data = data.frame(),
    aes(
      x = c(Inf, -Inf),
      y = c(-Inf, -Inf),
      hjust = c(1, 0),
      vjust = c(-1, -1),
      label = c("AD", " Control"),
      size = 5,
      fontface = "bold")
    )

plot_cor(complete_results, pal = "RdBu", pal_rev = TRUE)
colnames(complete_results) <- short_names # Below function doesn't currently work with `long_names`.
plot_single(complete_results, sig$name, "centered") + xlab(element_blank())
colnames(complete_results) <- long_names
datatable_download(results)
# -----------------
```

**Proteins DE without multiple correction testing**

```{r, fig.height = 30}
no_mult_testing <- results[results$AD_vs_Control_p.val < 0.05, ]
no_mult_testing <- complete_results[rownames(complete_results) %in% no_mult_testing$name, ]
Heatmap(
  assay(no_mult_testing),
  color,
  column_names_side = "top",
  show_column_names = TRUE,
  cluster_columns = FALSE,
  row_dend_side = "right",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "log2 Intensity", title_position = "leftcenter-rot"),
  row_names_gp = gpar(fontsize = 6),
  column_names_gp = gpar(fontsize = 16)
)
rm(no_mult_testing)
```

## Gene Set Enrichment

We perform gene set enrichment using methods available from the `GSVA` package [@hanzelmannGSVAGeneSet2013].
The Z-score method appears to be generally better for separating conditions while SSGSEA appears to highlight differential enrichment between gene sets.
`limma` is applied following these methods to test if differences are significant, using a similar design as in previous sections.
Note that while this approach is described in the `GSVA` vignette, I am not sure if it is applicable to all methods in the package.

### Johnson 2020 Modules

We use WGCNA modules derived from a more than 2,000 sample AD proteomics study [@johnsonLargescaleProteomicAnalysis2020] as our gene sets.

```{r}
# Load gene sets and filter to improve GSVA normalization.
# --------------------------------------------------------
gene_sets <- getGmt(file.path(assets_dir, "gene-sets", "proteomics-modules.gmt"))
gene_sets <- filterGeneSets(gene_sets, 5, 500)
gene_sets
# --------------------------------------------------------

# Filter dataset to proteins in gene sets to reduce multiple testing correction burden.
# -------------------------------------------------------------------------------------
data_filt <- data[rownames(data) %in% unique(unlist(geneIds(gene_sets))), ]
print(paste0("Unique proteins in post-QC protein matrix: ", dim(data)[1]))
print(paste0("Unique proteins in gene sets: ", length(unique(unlist(geneIds(gene_sets))))))
print(
  paste0("Unique proteins in both post-QC protein matrix and gene sets: ", dim(data_filt)[1])
)
# -------------------------------------------------------------------------------------
```

**Z-score method**

```{r}
# Perform GSVA using `zscore` method.
# -----------------------------------
gsva <- gsva(assay(data_filt), gene_sets, method = "zscore", verbose = FALSE)
datatable_download(gsva)
# -----------------------------------

# Use limma to test for significance.
# -----------------------------------
limma_design <- model.matrix(~ 0 + design$condition + design$sex + design$month)
colnames(limma_design)[1:2] <- unique(design$condition)
colnames(limma_design)[3] <- "sex"
colnames(limma_design)[4] <- "month"
corr_fit <- duplicateCorrelation(gsva, limma_design, block = design$sample)
fit <- lmFit(gsva, limma_design, block = design$sample, cor = corr_fit$consensus)
contrast_mat <- makeContrasts(AD-Control, levels = limma_design)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat))
tests <- decideTests(cont_fit)
results <- topTable(cont_fit, 1, Inf)
datatable_download_exp(results)
# -----------------------------------
```

**Batch-corrected heatmap with metadata removed**

```{r}
design_formula <- model.matrix(~ 0 + design$condition)
corr_fit <- duplicateCorrelation(gsva, design_formula, block = design$sample)
corrected_data <- removeBatchEffect(
  gsva, design$sex, design$month,
  design = model.matrix(~ 0 + design$condition), block = design$sample, cor = corr_fit$consensus
)

heatmap_data <- corrected_data
colnames(heatmap_data) <- design$sample
heatmap_data <- avearrays(heatmap_data)
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  colorRampPalette(rev(brewer.pal(9, "RdBu")))(round(diff(range(heatmap_data)))),
  cluster_columns = FALSE,
  row_dend_side = "right",
  row_names_max_width = max_text_width(rownames(heatmap_data)),
  column_names_side = "top",
  column_split = c(rep("AD", 5), rep("Control", 4)),
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Z-score enrichment", title_position = "leftcenter-rot")
)
```

**Uncorrected heatmap with full metadata**

```{r}
Heatmap(
  gsva,
  colorRampPalette(rev(brewer.pal(9, "RdBu")))(round(diff(range(gsva)))),
  cluster_columns = FALSE,
  row_dend_side = "right",
  row_names_max_width = max_text_width(rownames(gsva)),
  column_names_side = "top",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Z-score enrichment", title_position = "leftcenter-rot")
)
```

**SSGSEA method**

```{r}
# Perform GSVA using `ssgsea` method.
# We also don't normalize and make all values positive to improve interpretability.
# ---------------------------------------------------------------------------------
gsva <- gsva(assay(data_filt), gene_sets, method = "ssgsea", ssgsea.norm = FALSE, verbose = FALSE)
gsva <- gsva + abs(min(gsva))
datatable_download(gsva)
# ---------------------------------------------------------------------------------

# Use limma to test for significance.
# -----------------------------------
limma_design <- model.matrix(~ 0 + design$condition + design$sex + design$month)
colnames(limma_design)[1:2] <- unique(design$condition)
colnames(limma_design)[3] <- "sex"
colnames(limma_design)[4] <- "month"
corr_fit <- duplicateCorrelation(gsva, limma_design, block = design$sample)
fit <- lmFit(gsva, limma_design, block = design$sample, cor = corr_fit$consensus)
contrast_mat <- makeContrasts(AD-Control, levels = limma_design)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat))
tests <- decideTests(cont_fit)
results <- topTable(cont_fit, 1, Inf)
datatable_download_exp(results)
# -----------------------------------
```

**Batch-corrected heatmap with metadata removed**

```{r}
design_formula <- model.matrix(~ 0 + design$condition)
corr_fit <- duplicateCorrelation(gsva, design_formula, block = design$sample)
corrected_data <- removeBatchEffect(
  gsva, design$sex, design$month,
  design = model.matrix(~ 0 + design$condition), block = design$sample, cor = corr_fit$consensus
)

heatmap_data <- corrected_data
colnames(heatmap_data) <- design$sample
heatmap_data <- avearrays(heatmap_data)
heatmap_data <- heatmap_data[order(rowMedians(heatmap_data), decreasing = TRUE), ]
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  colorRampPalette(brewer.pal(9, "YlOrBr"))(round(max(heatmap_data))),
  cluster_columns = FALSE,
  cluster_rows = FALSE,
  row_dend_side = "right",
  row_names_max_width = max_text_width(rownames(heatmap_data)),
  column_names_side = "top",
  column_split = c(rep("AD", 5), rep("Control", 4)),
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "SSGSEA enrichment", title_position = "leftcenter-rot")
)
```

**Uncorrected heatmap with full metadata**

```{r}
gsva <- gsva[order(rowMedians(gsva), decreasing = TRUE), ]
Heatmap(
  gsva,
  colorRampPalette(brewer.pal(9, "YlOrBr"))(round(max(gsva))),
  cluster_columns = FALSE,
  cluster_rows = FALSE,
  row_names_max_width = max_text_width(rownames(gsva)),
  column_names_side = "top",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "SSGSEA enrichment", title_position = "leftcenter-rot")
)
```

**Plot individual genes for each gene set (unscaled and uncorrected)**

```{r, fig.height = 30}
for (sets in names(gene_sets)) {
  genes <- gene_sets[[sets]]@geneIds
  heatmap_data <- data[rownames(data) %in% genes, ]
  print(sets)
  draw(
    Heatmap(
      assay(heatmap_data),
      color,
      column_names_side = "top",
      show_column_names = TRUE,
      cluster_columns = FALSE,
      row_dend_side = "right",
      top_anno = top_anno,
      column_split = design$condition,
      column_gap = unit(2, "mm"),
      heatmap_legend_param = list(title = "log2 Intensity", title_position = "leftcenter-rot"),
      row_names_gp = gpar(fontsize = 6),
      column_names_gp = gpar(fontsize = 16)
    )
  )
}
```

### Panglao Cell Types

We use cell-type markers from the PanglaoDB database [https://panglaodb.se/markers.html](https://panglaodb.se/markers.html).

```{r}
# Load gene sets and filter to improve GSVA normalization.
# --------------------------------------------------------
gene_sets <- getGmt(file.path(assets_dir, "gene-sets", "panglao-brain-ctypes.gmt"))
gene_sets <- filterGeneSets(gene_sets, 5, 500)
gene_sets
# --------------------------------------------------------

# Filter dataset to proteins in gene sets to reduce multiple testing correction burden.
# -------------------------------------------------------------------------------------
data_filt <- data[rownames(data) %in% unique(unlist(geneIds(gene_sets))), ]
print(paste0("Unique proteins in post-QC protein matrix: ", dim(data)[1]))
print(paste0("Unique proteins in gene sets: ", length(unique(unlist(geneIds(gene_sets))))))
print(
  paste0("Unique proteins in both post-QC protein matrix and gene sets: ", dim(data_filt)[1])
)
# -------------------------------------------------------------------------------------
```

**Z-score method**

```{r}
# Perform GSVA using `zscore` method.
# -----------------------------------
gsva <- gsva(assay(data_filt), gene_sets, method = "zscore", verbose = FALSE)
datatable_download(gsva)
# -----------------------------------

# Use limma to test for significance.
# -----------------------------------
limma_design <- model.matrix(~ 0 + design$condition + design$sex + design$month)
colnames(limma_design)[1:2] <- unique(design$condition)
colnames(limma_design)[3] <- "sex"
colnames(limma_design)[4] <- "month"
corr_fit <- duplicateCorrelation(gsva, limma_design, block = design$sample)
fit <- lmFit(gsva, limma_design, block = design$sample, cor = corr_fit$consensus)
contrast_mat <- makeContrasts(AD-Control, levels = limma_design)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat))
tests <- decideTests(cont_fit)
results <- topTable(cont_fit, 1, Inf)
datatable_download_exp(results)
# -----------------------------------
```

**Batch-corrected heatmap with metadata removed**

```{r}
design_formula <- model.matrix(~ 0 + design$condition)
corr_fit <- duplicateCorrelation(gsva, design_formula, block = design$sample)
corrected_data <- removeBatchEffect(
  gsva, design$sex, design$month,
  design = model.matrix(~ 0 + design$condition), block = design$sample, cor = corr_fit$consensus
)

heatmap_data <- corrected_data
colnames(heatmap_data) <- design$sample
heatmap_data <- avearrays(heatmap_data)
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  colorRampPalette(rev(brewer.pal(9, "RdBu")))(round(diff(range(heatmap_data)))),
  cluster_columns = FALSE,
  row_dend_side = "right",
  row_names_max_width = max_text_width(rownames(heatmap_data)),
  column_names_side = "top",
  column_split = c(rep("AD", 5), rep("Control", 4)),
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Z-score enrichment", title_position = "leftcenter-rot")
)
```

**Uncorrected heatmap with full metadata**

```{r}
Heatmap(
  gsva,
  colorRampPalette(rev(brewer.pal(9, "RdBu")))(round(diff(range(gsva)))),
  cluster_columns = FALSE,
  row_dend_side = "right",
  row_names_max_width = max_text_width(rownames(gsva)),
  column_names_side = "top",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "Z-score enrichment", title_position = "leftcenter-rot")
)
```

**SSGSEA method**

```{r}
# Perform GSVA using `ssgsea` method.
# We also don't normalize and make all values positive to improve interpretability.
# ---------------------------------------------------------------------------------
gsva <- gsva(assay(data_filt), gene_sets, method = "ssgsea", ssgsea.norm = FALSE, verbose = FALSE)
gsva <- gsva + abs(min(gsva))
datatable_download(gsva)
# ---------------------------------------------------------------------------------

# Use limma to test for significance.
# -----------------------------------
limma_design <- model.matrix(~ 0 + design$condition + design$sex + design$month)
colnames(limma_design)[1:2] <- unique(design$condition)
colnames(limma_design)[3] <- "sex"
colnames(limma_design)[4] <- "month"
corr_fit <- duplicateCorrelation(gsva, limma_design, block = design$sample)
fit <- lmFit(gsva, limma_design, block = design$sample, cor = corr_fit$consensus)
contrast_mat <- makeContrasts(AD-Control, levels = limma_design)
cont_fit <- eBayes(contrasts.fit(fit, contrast_mat))
tests <- decideTests(cont_fit)
results <- topTable(cont_fit, 1, Inf)
datatable_download_exp(results)
# -----------------------------------
```

**Batch-corrected heatmap with metadata removed**

```{r}
design_formula <- model.matrix(~ 0 + design$condition)
corr_fit <- duplicateCorrelation(gsva, design_formula, block = design$sample)
corrected_data <- removeBatchEffect(
  gsva, design$sex, design$month,
  design = model.matrix(~ 0 + design$condition), block = design$sample, cor = corr_fit$consensus
)

heatmap_data <- corrected_data
colnames(heatmap_data) <- design$sample
heatmap_data <- avearrays(heatmap_data)
heatmap_data <- heatmap_data[order(rowMedians(heatmap_data), decreasing = TRUE), ]
color2 <- colorRamp2(
  c(min(heatmap_data), (max(heatmap_data) + min(heatmap_data)) / 2, max(heatmap_data)),
  c(brewer.pal(3, "RdYlBu")[3], brewer.pal(3, "RdYlBu")[2], brewer.pal(3, "RdYlBu")[1])
)
Heatmap(
  heatmap_data,
  colorRampPalette(brewer.pal(9, "YlOrBr"))(round(max(heatmap_data))),
  cluster_columns = FALSE,
  cluster_rows = FALSE,
  row_dend_side = "right",
  row_names_max_width = max_text_width(rownames(heatmap_data)),
  column_names_side = "top",
  column_split = c(rep("AD", 5), rep("Control", 4)),
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "SSGSEA enrichment", title_position = "leftcenter-rot")
)
```

**Uncorrected heatmap with full metadata**

```{r}
gsva <- gsva[order(rowMedians(gsva), decreasing = TRUE), ]
Heatmap(
  gsva,
  colorRampPalette(brewer.pal(9, "YlOrBr"))(round(max(gsva))),
  cluster_columns = FALSE,
  cluster_rows = FALSE,
  row_names_max_width = max_text_width(rownames(gsva)),
  column_names_side = "top",
  top_anno = top_anno,
  column_split = design$condition,
  column_gap = unit(2, "mm"),
  heatmap_legend_param = list(title = "SSGSEA enrichment", title_position = "leftcenter-rot")
)
```

**Plot individual genes for each gene set (unscaled and uncorrected)**

```{r, fig.height = 30}
for (sets in names(gene_sets)) {
  genes <- gene_sets[[sets]]@geneIds
  heatmap_data <- data[rownames(data) %in% genes, ]
  print(sets)
  draw(
    Heatmap(
      assay(heatmap_data),
      color,
      column_names_side = "top",
      show_column_names = TRUE,
      cluster_columns = FALSE,
      row_dend_side = "right",
      top_anno = top_anno,
      column_split = design$condition,
      column_gap = unit(2, "mm"),
      heatmap_legend_param = list(title = "log2 Intensity", title_position = "leftcenter-rot"),
      row_names_gp = gpar(fontsize = 6),
      column_names_gp = gpar(fontsize = 16)
    )
  )
}
```

# References

This is the concluding section of the document, where we output the `sessionInfo`, and create a bibliography for works cited.

```{r}
sessionInfo()
```
