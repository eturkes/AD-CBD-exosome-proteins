---
title: "Dataset 1 AD CBD CTRL"
author:
  - name: "Emir Turkes [emir.turkes@eturkes.com]"
  - name: "UK Dementia Research Institute at UCL"
date: '`r strftime(Sys.time(), "%B %d, %Y")`'
bibliography: "../AD-CBD-exosome-proteins.bib"
link-citations: true
output:
  html_document:
    code_folding: hide
    number_sections: true
    theme: lumen
    highlight: haddock
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: false
      smooth_scroll: false
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_file = file.path(
    "..", "results", "dataset1-AD-CBD-CTRL.html"
  ))})
---

<style type="text/css">
body {font-size: 16px;}
h1.title {font-size: 35px;}
h1 {font-size: 24px;}
h2 {font-size: 22px;}
h3 {font-size: 20px;}
.toc-content {padding-left: 0px; padding-right: 0px;}
div.tocify {width: 100%;}
.tocify-subheader .tocify-item {font-size: 0.95em; padding-left: 25px; text-indent: 0;}
.tocify-subheader .tocify-subheader .tocify-item {
  font-size: 0.95em; padding-left: 35px; text-indent: 0;
}
div.main-container {max-width: none; width: 100%;}
</style>

*This file is a part of [AD-CBD-exosome-proteins](https://github.com/eturkes/AD-CBD-exosome-proteins).*
*Please email me for access.*

The data here is derived from @dataset1 and will be referenced using the name `dataset1`.

The background for this data is as follows:
- Two replicates of control, Alzheimer's Disease (AD), and Corticobasal Degeneration (CBD) patient brain samples.
- Mass spectrometry data of exosome proteins analyzed with MaxQuant.

```{r}
# Copyright 2019-2020 Emir Turkes, Guar Pallavi, Stephanie Fowler, UK DRI at UCL, Columbia
# University Medical Center
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This section should be checked per document.
# --------------------------------------------
options(stringsAsFactors = FALSE)
packages <- c(
"conflicted", "DT", "data.table", "readxl", "pheatmap", "plyr", "RColorBrewer", "UpSetR", "grid"
)
invisible(suppressPackageStartupMessages(lapply(packages, library, character.only = TRUE)))
source(file.path(getwd(), "utils.R"))

data_name <- "dataset1"
# --------------------------------------------

# Everything else in this chunk remains generally unchanged.
# ----------------------------------------------------------
assets_dir <- file.path(getwd(), "..", "assets") # Backed up data.

cache_dir <- file.path(getwd(), "..", "tmp", "cache")
if (!dir.exists(cache_dir)) {
  dir.create(cache_dir, recursive = TRUE)
}

knitr::opts_chunk$set(fig.width = 10, fig.height = 7)
```

# Original Data {.tabset}

This section contains the original data received from the mass spec facility and was mainly processed using MaxQuant.

```{r}
AD_control <- data.table(
  read_excel(file.path(assets_dir, data_name, "AD_CONTROL_DIFFERENCE_08202019.xls"), na = "NaN")
)
CBD_control <- data.table(
  read_excel(file.path(assets_dir, data_name, "CBD_CONTROL_DIFFERENCE_08202019.xls"), na = "NaN")
)
AD_CBD <- data.table(
  read_excel(file.path(assets_dir, data_name, "AD_CDB_DIFFERENCE_08202019.xls"), na = "NaN")
)
sets <- list(AD_control, CBD_control, AD_CBD)
```

## AD vs. Control

```{r}
datatable_download_exp(sets[[1]])
```

## CBD vs. Control

```{r}
datatable_download_exp(sets[[2]])
```

## AD vs. CBD

```{r}
datatable_download_exp(sets[[3]])
```

# Preliminary Cleaning {.tabset}

First, we clean up the data and apply a p-value cutoff at 0.05.

```{r}
sets <- lapply(sets, function(x) x[ , c(6, 3, 2)])
sets <- lapply(sets, function(x) rename(x, c("Gene names" = "Genes", "p value" = "p_value")))
sets[[1]] <- rename(sets[[1]], c("AD_Control fold diff" = "AD_Control_Fold_Change"))
sets[[2]] <- rename(sets[[2]], c("CBD_Control_Fold difference" = "CBD_Control_Fold_Change"))
sets[[3]] <- rename(sets[[3]], c("AD_CDB_FoldDifference" = "AD_CBD_Fold_Change"))

sets <- lapply(sets, function(x) x[x$p_value < 0.05, ])
sets <- lapply(sets, function(x) x[!duplicated(x$Genes) | !is.na(x$Genes) | !x$Genes == "", ])
sets <- lapply(sets, function(x) x[!is.na(x$Genes), ])
sets <- lapply(sets, function(x) x[!x$Genes == "", ])
sets <- lapply(sets, function(x) replace(x, is.na(x), as.double("NA"))) # Use proper type.
sets <- lapply(sets, function(x) x[order(-x[ , 2])]) # Order by fold change.
```

## AD vs. Control

```{r}
datatable_download_exp(sets[[1]]) %>% formatStyle("Genes", `text-align` = "center")
```

## CBD vs. Control

```{r}
datatable_download_exp(sets[[2]]) %>% formatStyle("Genes", `text-align` = "center")
```

## AD vs. CBD

```{r}
datatable_download_exp(sets[[3]]) %>% formatStyle("Genes", `text-align` = "center")
```

# Differential Expression

We start by characterizing the differential expression of proteins in our two treatment conditions and three datasets.
The data is log-transformed to summarize both positive and negative relationships.

```{r}
merged_set <- Reduce(
  function(...) merge(..., all = TRUE),
  list(sets[[1]][ , c(1, 2)], sets[[2]][ , c(1, 2)], sets[[3]][ , c(1, 2)])
)
merged_set <- merged_set[!duplicated(merged_set$Genes), ]
merged_set <- merged_set[!is.na(merged_set$Genes), ]
merged_set <- merged_set[!merged_set$Genes == "", ]

merged_set$AD_Control_Fold_Change <- log2(merged_set$AD_Control_Fold_Change)
merged_set$CBD_Control_Fold_Change <- log2(merged_set$CBD_Control_Fold_Change)
merged_set$AD_CBD_Fold_Change <- log2(merged_set$AD_CBD_Fold_Change)
merged_set <- rename(merged_set, c(
  "AD_Control_Fold_Change" = "log2_AD_Control_Fold_Change",
  "CBD_Control_Fold_Change" = "log2_CBD_Control_Fold_Change",
  "AD_CBD_Fold_Change" = "log2_AD_CBD_Fold_Change")
)

datatable_download(merged_set) %>%
  formatStyle("Genes", `text-align` = "center") %>%
  formatRound(columns = c(2:dim(merged_set)[2]), digits = 2)
```

To narrow down the data, we start by comparing the top within-group differentially expressed proteins for each dataset.

## Positive + Negative

In order to capture both positive and negative relationships, we subset the top 20 genes of each condition using the absolute value of the log2 fold changes.

```{r}
AD_control <- head(merged_set[order(-abs(merged_set$log2_AD_Control_Fold_Change))], 20)
CBD_control <- head(merged_set[order(-abs(merged_set$log2_CBD_Control_Fold_Change))], 20)
AD_CBD <- head(merged_set[order(-abs(merged_set$log2_AD_CBD_Fold_Change))], 20)

merged_top <- Reduce(
  function(...) merge(..., all = TRUE),
  list(AD_control[ , c(1, 2)], CBD_control[ , c(1, 3)], AD_CBD[ , c(1, 4)])
)
merged_top <- merged_top[!duplicated(merged_top$Genes), ]
merged_top <- merged_top[!is.na(merged_top$Genes), ]
merged_top <- merged_top[!merged_top$Genes == "", ]

top_genes <- merged_top$Genes
merged_top <- merged_top[ , 2:dim(merged_top)[2]]
rownames(merged_top) <- top_genes
datatable_download(merged_top) %>% formatRound(columns = c(1:dim(merged_top)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate NA values.
merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
merged_top <- replace(merged_top, is.na(merged_top), 0)
color <- colorRampPalette(rev(brewer.pal(7, "RdYlBu")))(100)
color[50] <- "#DDDDDD"
breaks <- c(
  seq(min(merged_top), -0.001, abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), abs(max(merged_top)) / 50)
)
pheatmap(merged_top, color, angle_col = 0, fontsize = 9, cluster_cols = FALSE, breaks = breaks)
```

UpSet plots [@conwayUpSetRPackageVisualization2017] help visualize set interactions among entities, similar to a Venn diagram.
Each dot depicts a set membership combination and the main bar plot shows how many genes pass statistical thresholds to exhibit the combination.
These provide no indication of directionality (i.e. up vs. downregulated), however the bottom right scatter plot is able to summarize that (note that genes not passing the statistical threshold are reported with a value of 0).
The bottom left scatter plot are overall metrics of absolute maximum values for each gene and the absolute sums across all conditions, while the left bar plot indicates that 20 genes from each condition were used for this figure.
The selected genes queried are the top 10 genes based on their absolute value maximums.

```{r}
# Prepare additional metadata.
abs_max <- apply(merged_top, 1, function(x) max(abs(x)))
abs_rowsums <- rowSums(abs(merged_top))
merged_top <- as.data.frame(merged_top)
log2_AD_Control_Fold_Change <- merged_top$log2_AD_Control_Fold_Change
log2_CBD_Control_Fold_Change <- merged_top$log2_CBD_Control_Fold_Change

# Convert into a binary matrix.
merged_top <- as.matrix(merged_top)
merged_top[merged_top != 0] <- 1

# Add metadata after conversion.
merged_top <- as.data.frame(merged_top)
merged_top$absolute_max <- abs_max
merged_top$absolute_rowsums <- abs_rowsums
merged_top <- rename(merged_top, c(
  "log2_AD_Control_Fold_Change" = "AD_Control_Fold_Change",
  "log2_CBD_Control_Fold_Change" = "CBD_Control_Fold_Change",
  "log2_AD_CBD_Fold_Change" = "AD_CBD_Fold_Change")
)
merged_top$log2_AD_Control_Fold_Change <- log2_AD_Control_Fold_Change
merged_top$log2_CBD_Control_Fold_Change <- log2_CBD_Control_Fold_Change
merged_top <- setDT(merged_top, keep.rownames = TRUE)[]
colnames(merged_top)[1] <- "Genes"

# Query the top 10 genes based on row wise absolute value maximums.
max_genes <- top_genes[order(-abs_max)]
queries <- list()
for (i in 1:10) {
  gene <- max_genes[i]
  name <- paste("query", i, sep = "")
  tmp <- list(query = elements, params = list("Genes", gene), query.name = gene)
  queries[[name]] <- tmp
}

set.seed(3) # Placement of jitter points is non-deterministic.
upset(
  merged_top,
  empty.intersections = "on",
  query.legend = "bottom",
  queries = queries,
  attribute.plots = list(
    gridrows = 45,
    ncols = 2,
    plots = list(
      list(plot = scatter_plot, x = "absolute_max", y = "absolute_rowsums", queries = TRUE),
      list(
        plot = scatter_plot, x = "log2_AD_Control_Fold_Change",
        y = "log2_CBD_Control_Fold_Change", queries = TRUE
      )
    )
  )
)
```

We create the same plot, this time with the top 10 genes based on their absolute value sum across conditions.

```{r}
# Query the top 10 genes based on row wise absolute value rowsums.
rowsums_genes <- top_genes[order(-abs_rowsums)]
queries <- list()
for (i in 1:10) {
  gene <- rowsums_genes[i]
  name <- paste("query", i, sep = "")
  tmp <- list(query = elements, params = list("Genes", gene), query.name = gene)
  queries[[name]] <- tmp
}

set.seed(3) # Placement of jitter points is non-deterministic.
upset(
  merged_top,
  empty.intersections = "on",
  query.legend = "bottom",
  queries = queries,
  attribute.plots = list(
    gridrows = 45,
    ncols = 2,
    plots = list(
      list(plot = scatter_plot, x = "absolute_max", y = "absolute_rowsums", queries = TRUE),
      list(
        plot = scatter_plot, x = "log2_AD_Control_Fold_Change",
        y = "log2_CBD_Control_Fold_Change", queries = TRUE
      )
    )
  )
)
```

We construct a different UpSet plot depicting genes that have membership in two or more sets.

```{r}
# Transpose the data for a second UpSet plot.
merged_top <- merged_top[ , 1:4]
merged_top <- t(merged_top)
colnames(merged_top) <- as.character(unlist(merged_top[1, ]))
merged_top <- merged_top[-1, ]
mode(merged_top) = "numeric" # Transformations originally produced a character matrix.
merged_top <- as.data.frame(merged_top)
merged_top <- merged_top[, colSums(merged_top) != 1]
merged_top <- setDT(merged_top, TRUE)[]
colnames(merged_top)[1] <- "Conditions"

upset(
  merged_top, dim(merged_top)[2], mb.ratio = c(0, 0.1),
  sets.x.label = "Genes", set_size.show = FALSE
)

# Use titles as column labels as a workaround.
grid.text(
  "log2_AD_Control_Fold_Change     log2_CBD_Control_Fold_Change     log2_AD_CBD_Fold_Change",
  0.64,
  0.99,
  gp = gpar(fontsize = 7))
```

We make another heatmap, this time excluding the AD vs. CBD group, using the top 30 genes of each condition from the absolute value of the log2 fold changes.

```{r}
AD_control <- head(merged_set[order(-abs(merged_set$log2_AD_Control_Fold_Change))], 30)
CBD_control <- head(merged_set[order(-abs(merged_set$log2_CBD_Control_Fold_Change))], 30)

merged_top <- Reduce(
  function(...) merge(..., all = TRUE),
  list(AD_control[ , c(1, 2)], CBD_control[ , c(1, 3)])
)
merged_top <- merged_top[!duplicated(merged_top$Genes), ]
merged_top <- merged_top[!is.na(merged_top$Genes), ]
merged_top <- merged_top[!merged_top$Genes == "", ]

top_genes <- merged_top$Genes
merged_top <- merged_top[ , 2:dim(merged_top)[2]]
rownames(merged_top) <- top_genes
datatable_download(merged_top) %>% formatRound(columns = c(1:dim(merged_top)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate NA values.
merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
merged_top <- replace(merged_top, is.na(merged_top), 0)
color <- colorRampPalette(rev(brewer.pal(7, "RdYlBu")))(100)
color[50] <- "#DDDDDD"
breaks <- c(
  seq(min(merged_top), -0.001, abs(min(merged_top)) / 50), 0,
  seq(0.001, max(merged_top), abs(max(merged_top)) / 50)
)
pheatmap(merged_top, color, angle_col = 0, fontsize = 9, cluster_cols = FALSE, breaks = breaks)
```

## Positive Only

```{r}
AD_control <- head(merged_set[order(-merged_set$log2_AD_Control_Fold_Change)], 20)
CBD_control <- head(merged_set[order(-merged_set$log2_CBD_Control_Fold_Change)], 20)
AD_CBD <- head(merged_set[order(-merged_set$log2_AD_CBD_Fold_Change)], 20)

merged_top <- Reduce(
  function(...) merge(..., all = TRUE),
  list(AD_control[ , c(1, 2)], CBD_control[ , c(1, 3)], AD_CBD[ , c(1, 4)])
)
merged_top <- merged_top[!duplicated(merged_top$Genes), ]
merged_top <- merged_top[!is.na(merged_top$Genes), ]
merged_top <- merged_top[!merged_top$Genes == "", ]

top_genes <- merged_top$Genes
merged_top <- merged_top[ , 2:dim(merged_top)[2]]
rownames(merged_top) <- top_genes
datatable_download(merged_top) %>% formatRound(columns = c(1:dim(merged_top)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate NA values.
merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
merged_top <- replace(merged_top, is.na(merged_top), 0)
color <- colorRampPalette(brewer.pal(7, "Reds"))(100)
color[1] <- "#DDDDDD"
pheatmap(merged_top, color, angle_col = 0, fontsize = 9, cluster_cols = FALSE)
```

```{r}
AD_control <- head(merged_set[order(-merged_set$log2_AD_Control_Fold_Change)], 30)
CBD_control <- head(merged_set[order(-merged_set$log2_CBD_Control_Fold_Change)], 30)

merged_top <- Reduce(
  function(...) merge(..., all = TRUE),
  list(AD_control[ , c(1, 2)], CBD_control[ , c(1, 3)])
)
merged_top <- merged_top[!duplicated(merged_top$Genes), ]
merged_top <- merged_top[!is.na(merged_top$Genes), ]
merged_top <- merged_top[!merged_top$Genes == "", ]

top_genes <- merged_top$Genes
merged_top <- merged_top[ , 2:dim(merged_top)[2]]
rownames(merged_top) <- top_genes
datatable_download(merged_top) %>% formatRound(columns = c(1:dim(merged_top)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate NA values.
merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
merged_top <- replace(merged_top, is.na(merged_top), 0)
color <- colorRampPalette(brewer.pal(7, "Reds"))(100)
color[1] <- "#DDDDDD"
pheatmap(merged_top, color, angle_col = 0, fontsize = 9, cluster_cols = FALSE)
```

## Negative Only

```{r}
AD_control <- head(merged_set[order(merged_set$log2_AD_Control_Fold_Change)], 20)
CBD_control <- head(merged_set[order(merged_set$log2_CBD_Control_Fold_Change)], 20)
AD_CBD <- head(merged_set[order(merged_set$log2_AD_CBD_Fold_Change)], 20)

merged_top <- Reduce(
  function(...) merge(..., all = TRUE),
  list(AD_control[ , c(1, 2)], CBD_control[ , c(1, 3)], AD_CBD[ , c(1, 4)])
)
merged_top <- merged_top[!duplicated(merged_top$Genes), ]
merged_top <- merged_top[!is.na(merged_top$Genes), ]
merged_top <- merged_top[!merged_top$Genes == "", ]

top_genes <- merged_top$Genes
merged_top <- merged_top[ , 2:dim(merged_top)[2]]
rownames(merged_top) <- top_genes
datatable_download(merged_top) %>% formatRound(columns = c(1:dim(merged_top)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate NA values.
merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
merged_top <- replace(merged_top, is.na(merged_top), 0)
color <- colorRampPalette(brewer.pal(7, "Blues"))(100)
color[100] <- "#DDDDDD"
pheatmap(merged_top, color, angle_col = 0, fontsize = 9, cluster_cols = FALSE)
```

```{r}
AD_control <- head(merged_set[order(merged_set$log2_AD_Control_Fold_Change)], 30)
CBD_control <- head(merged_set[order(merged_set$log2_CBD_Control_Fold_Change)], 30)

merged_top <- Reduce(
  function(...) merge(..., all = TRUE),
  list(AD_control[ , c(1, 2)], CBD_control[ , c(1, 3)])
)
merged_top <- merged_top[!duplicated(merged_top$Genes), ]
merged_top <- merged_top[!is.na(merged_top$Genes), ]
merged_top <- merged_top[!merged_top$Genes == "", ]

top_genes <- merged_top$Genes
merged_top <- merged_top[ , 2:dim(merged_top)[2]]
rownames(merged_top) <- top_genes
datatable_download(merged_top) %>% formatRound(columns = c(1:dim(merged_top)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate NA values.
merged_top <- as.matrix(merged_top)
rownames(merged_top) <- top_genes
merged_top <- replace(merged_top, is.na(merged_top), 0)
color <- colorRampPalette(brewer.pal(7, "Blues"))(100)
color[100] <- "#DDDDDD"
pheatmap(merged_top, color, angle_col = 0, fontsize = 9, cluster_cols = FALSE)
```

# Disease Specific

The analysis so far reveals proteins that are both differentially expressed in disease conditions compared to controls and between diseases.
Such cases are interesting as they suggest with high confidence proteins that are specifically associated with disease over the other.
We therefore make additional heatmaps to highlight these proteins in particular.

## Positive + Negative

```{r}
merged_spec <- merged_set[!with(
  merged_set, is.na(log2_AD_Control_Fold_Change) & is.na(log2_CBD_Control_Fold_Change)
), ]
merged_spec <- merged_spec[order(-abs(merged_spec$log2_AD_CBD_Fold_Change))]

merged_genes <- merged_spec$Genes
merged_spec <- merged_spec[ , 2:dim(merged_spec)[2]]
rownames(merged_spec) <- merged_genes
datatable_download(merged_spec) %>% formatRound(columns = c(2:dim(merged_spec)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate NA values.
merged_spec <- as.matrix(head(merged_spec, 50))
rownames(merged_spec) <- head(merged_genes, 50)
merged_spec <- replace(merged_spec, is.na(merged_spec), 0)
color <- colorRampPalette(rev(brewer.pal(7, "RdYlBu")))(100)
color[50] <- "#DDDDDD"
breaks <- c(
  seq(min(merged_spec), -0.001, abs(min(merged_spec)) / 50), 0,
  seq(0.001, max(merged_spec), abs(max(merged_spec)) / 50)
)
pheatmap(merged_spec, color, angle_col = 0, fontsize = 9, cluster_cols = FALSE, breaks = breaks)
```

## Positive Only

```{r}
merged_spec <- merged_set[!with(
  merged_set, is.na(log2_AD_Control_Fold_Change) & is.na(log2_CBD_Control_Fold_Change)
), ]
merged_spec <- merged_spec[order(-merged_spec$log2_AD_CBD_Fold_Change)]

merged_genes <- merged_spec$Genes
merged_spec <- merged_spec[ , 2:dim(merged_spec)[2]]
rownames(merged_spec) <- merged_genes
datatable_download(merged_spec) %>% formatRound(columns = c(2:dim(merged_spec)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate NA values.
merged_spec <- as.matrix(head(merged_spec, 50))
rownames(merged_spec) <- head(merged_genes, 50)
merged_spec <- replace(merged_spec, is.na(merged_spec), 0)
color <- colorRampPalette(brewer.pal(7, "Reds"))(100)
color[1] <- "#DDDDDD"
breaks <- c(
  seq(min(merged_spec), -0.001, abs(min(merged_spec)) / 50), 0,
  seq(0.001, max(merged_spec), abs(max(merged_spec)) / 50)
)
pheatmap(merged_spec, color, angle_col = 0, fontsize = 9, cluster_cols = FALSE, breaks = breaks)
```

## Negative Only

```{r}
merged_spec <- merged_set[!with(
  merged_set, is.na(log2_AD_Control_Fold_Change) & is.na(log2_CBD_Control_Fold_Change)
), ]
merged_spec <- merged_spec[order(merged_spec$log2_AD_CBD_Fold_Change)]

merged_genes <- merged_spec$Genes
merged_spec <- merged_spec[ , 2:dim(merged_spec)[2]]
rownames(merged_spec) <- merged_genes
datatable_download(merged_spec) %>% formatRound(columns = c(2:dim(merged_spec)[2]), digits = 2)

# Generate heatmap, using grey for 0 in color palette to indicate NA values.
merged_spec <- as.matrix(head(merged_spec, 50))
rownames(merged_spec) <- head(merged_genes, 50)
merged_spec <- replace(merged_spec, is.na(merged_spec), 0)
color <- colorRampPalette(brewer.pal(7, "Blues"))(100)
color[100] <- "#DDDDDD"
breaks <- c(
  seq(min(merged_spec), -0.001, abs(min(merged_spec)) / 50), 0,
  seq(0.001, max(merged_spec), abs(max(merged_spec)) / 50)
)
pheatmap(merged_spec, color, angle_col = 0, fontsize = 9, cluster_cols = FALSE, breaks = breaks)
```

# References

This is the concluding section of the document, where we output the `sessionInfo`, and create a bibliography for works cited.

```{r}
sessionInfo()
```
